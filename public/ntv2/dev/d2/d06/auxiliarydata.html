<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AJA NTV2 SDK: HDMI Auxiliary Data</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../ajastyles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../AJALogoMini.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AJA NTV2 SDK
   &#160;<span id="projectnumber">17.5.0.1516</span>
   </div>
   <div id="projectbrief">NTV2 SDK 17.5.0.1516</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d2/d06/auxiliarydata.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">HDMI Auxiliary Data </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Starting in SDK 17.1, some of AJA’s devices with HDMI inputs support the capture of HDMI auxiliary data using AJA’s inserter/extractor firmware technology.</p>
<dl class="section note"><dt>Note</dt><dd>Although <b>HDMI Aux playback</b> is documented here, the feature is <b>not currently implemented</b>. AJA plans to complete this feature in a future firmware and SDK release.</dd></dl>
<p><b>CONTENTS:</b></p><ul>
<li><a class="el" href="../../d2/d06/auxiliarydata.html#auxcapture">Custom Aux Packet Capture</a><ul>
<li><a class="el" href="../../d2/d06/auxiliarydata.html#auxcapture-filter">Auxiliary Packet Filtering</a></li>
<li><a class="el" href="../../d2/d06/auxiliarydata.html#auxcapture-dataspace">Auxiliary Data Space Limitations</a></li>
</ul>
</li>
<li><a class="el" href="../../d2/d06/auxiliarydata.html#auxplayout">HDMI Auxiliary Data Playout</a></li>
<li><a class="el" href="../../d2/d06/auxiliarydata.html#auxbufferformat">HDMI Aux Buffer Data Format</a></li>
</ul>
<hr  size="50px" />
<h1><a class="anchor" id="auxcapture"></a>
Custom Aux Packet Capture</h1>
<p>The only way to capture any/all Auxiliary data packets is by way of the Aux Extractor firmware.</p><ul>
<li>Check that <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a03c21b09974ff7b8895282ef5f87be62">CNTV2Card::features</a> ⟹ DeviceCapabilities::CanDoHDMIAuxCapture returns <code>true</code> if this feature is supported.</li>
<li>When properly configured and enabled, HDMI Aux data packets are automatically extracted from the HDMI input video stream and placed into a separate area of the device frame buffer.</li>
<li>With <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> :<ul>
<li>SDK &amp; driver version 17.1 or later required.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb" title="Prepares for subsequent AutoCirculate ingest, designating a contiguous block of frame buffers on the ...">CNTV2Card::AutoCirculateInitForInput</a> with the <a class="el" href="../../d4/dd7/ntv2publicinterface_8h.html#aaf8e112c67edba0b52c9ae9dc4b78427" title="Use this to AutoCirculate with HDMI auxiliary data.">AUTOCIRCULATE_WITH_HDMIAUX</a> option.</li>
<li>Call <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#ad7480e96337587fd0035a42f6d43b17d" title="Sets my ancillary data buffers for use in a subsequent call to CNTV2Card::AutoCirculateTransfer.">AUTOCIRCULATE_TRANSFER::SetAncBuffers</a> to specify the destination host Aux buffer(s).</li>
<li>After <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a> returns, parse the contents of the host Aux buffer(s).<ul>
<li>AUTOCIRCULATE_TRANSFER::GetCapturedAuxByteCount reports the number of bytes recorded/written into the device frame’s anc buffer region.</li>
<li>Manually parse the anc data that was recorded and transferred — see <a class="el" href="../../d2/d06/auxiliarydata.html#auxbufferformat">HDMI Aux Buffer Data Format</a>.</li>
<li>Or use the <a class="el" href="../../de/d4b/ajaanc.html">Ancillary Data Classes</a> — call <a class="el" href="../../d8/def/class_a_j_a_ancillary_list.html#a7a2f425d823df9f88934bacf2130213b" title="Returns all ancillary data packets found in the given F1 and F2 ancillary data buffers.">AJAAuxiliaryList::SetFromDeviceAncBuffers</a> to retrieve the <a class="el" href="../../d7/d92/ancillarydata_8h.html#a2c180fa75e261e39b0691fe2326c20fe">AJAAuxiliaryData</a> packets.</li>
</ul>
</li>
</ul>
</li>
<li>Without <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> :<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a5a2d48a0e5020ac3d36ca96d20288dfe" title="Answers with the number of bytes of field 1 ANC extracted.">CNTV2Card::AuxExtractGetField1Size</a> and <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ab91463bfe72f47f05a8fb584390a901e" title="Answers with the number of bytes of field 2 HDMI AUX data extracted.">CNTV2Card::AuxExtractGetField2Size</a> to note how many HDMI Aux data bytes were recorded/written into the device frame buffer’s Aux region for Field1 and Field2, respectively.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2f2fc32a8fac7f8b10a7f82534f185ae" title="Transfers the contents of the ancillary data buffer(s) from a given frame on the AJA device to the ho...">CNTV2Card::DMAReadAnc</a> to transfer the captured HDMI Aux data to the host.</li>
<li>Parse the contents of the host Aux buffer(s):<ul>
<li>Manually parse the aux data that was recorded/transferred — see <a class="el" href="../../d2/d06/auxiliarydata.html#auxbufferformat">HDMI Aux Buffer Data Format</a> (below).</li>
<li>Or use the <a class="el" href="../../de/d4b/ajaanc.html">Ancillary Data Classes</a> — call <a class="el" href="../../d8/def/class_a_j_a_ancillary_list.html#a0d869d76c4ed7533e0d5d1acfce0b88b" title="Returns all HDMI Aux data packets found in the given F1 and F2 aux data buffers.">AJAAuxiliaryList::SetFromDeviceAuxBuffers</a> to retrieve the <a class="el" href="../../d7/d92/ancillarydata_8h.html#a2c180fa75e261e39b0691fe2326c20fe">AJAAuxiliaryData</a> packets.</li>
</ul>
</li>
</ul>
</li>
<li>Each Aux Extractor is capable of filtering certain types of auxiliary data packets:<ul>
<li>Upon driver startup, all Aux Extractors are configured to exclude nothing (include everything).</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a8ee7a72f5752ae9deff029071e756a28" title="Answers with the HDMI packet types currently being excluded (filtered) by the HDMI input&#39;s Aux extrac...">CNTV2Card::AuxExtractGetPacketFilters</a> to discover which packet DIDs are currently being excluded.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463" title="Replaces the HDMI packet types to be excluded (filtered) by the given HDMI input&#39;s Aux extractor.">CNTV2Card::AuxExtractSetPacketFilters</a> to change which packet DIDs will be excluded.</li>
<li>Use the <a class="el" href="../../d4/dd7/ntv2publicinterface_8h.html#ac815846292eb113e60b58c91ffc67708" title="A set of distinct NTV2DID values.">NTV2DIDSet</a> returned from <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a6e6725d829f87f103e56dce05cea2582">CNTV2Card::AuxExtractGetDefaultPacketFilters</a> to restore the default packet exclusion list.</li>
</ul>
</li>
<li>The default maximum per-field auxiliary data buffer capacity is 8K by default, or 16K per-frame, including overhead.</li>
</ul>
<p><b>TIP:</b> The <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> tool’s <a class="el" href="../../db/d02/toolsandutilities.html#inspectoranc">Ancillary Data Inspector</a> is useful for diagnosing issues with auxiliary data capture.</p>
<h2><a class="anchor" id="auxcapture-filter"></a>
Auxiliary Packet Filtering</h2>
<p>For devices that support HDMI Aux capture, each HDMI input has an “Aux Extractor” widget associated with it. Each of these widgets have a filter that can exclude unwanted packets based on their Packet Type. Each filter is configured using five 32-bit registers, each register accommodating four Packet Type values, resulting in the ability to filter (exclude) up to 20 different types of packets.</p><ul>
<li>A non-zero byte value in a filter register will cause the Extractor to skip packets whose Packet Type matches that byte value.</li>
<li>A zero byte value is always ignored by the Extractor.</li>
<li>It is not an error to have the same Packet Type value in multiple byte positions in the filter registers.</li>
</ul>
<p>By default, the HDMI input’s Aux extractor widget is configured when <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb" title="Prepares for subsequent AutoCirculate ingest, designating a contiguous block of frame buffers on the ...">CNTV2Card::AutoCirculateInitForInput</a> (or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a97e28e638865fb8260cd81a251fc331b" title="Initializes the given SDI input&#39;s Anc extractor for custom Anc packet detection and de-embedding....">CNTV2Card::AncExtractInit</a>) are called. By default, the extractor is configured to NOT filter any packets.</p>
<dl class="section user"><dt>Disabling All Filtering</dt><dd></dd></dl>
<p>To disable all filtering of incoming auxiliary data packets, pass an empty NTV2DIDSet to <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463" title="Replaces the HDMI packet types to be excluded (filtered) by the given HDMI input&#39;s Aux extractor.">CNTV2Card::AuxExtractSetPacketFilters</a>. </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line">. . .</div>
<div class="line">const <a class="code" href="../../db/de2/ajatypes_8h.html#ae4440931f58d09da66ca92345018fb65">UWord</a> hdmiInput(<a class="code" href="../../db/de2/ajatypes_8h.html#ae4440931f58d09da66ca92345018fb65">UWord</a>(::<a class="code" href="../../d0/d81/ntv2utils_8h.html#a5e144bb8353e29ca6e9e24c5728e07df">GetIndexForNTV2InputSource</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3">NTV2_INPUTSOURCE_HDMI1</a>)));</div>
<div class="line">device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463">AuxExtractSetPacketFilters</a>(hdmiInput, <a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#ac815846292eb113e60b58c91ffc67708">NTV2DIDSet</a>());   <span class="comment">// Disable all filtering</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Changing packet filtering takes effect at the next captured frame.</dd></dl>
<dl class="section user"><dt>Filtering Specific Packet Types</dt><dd></dd></dl>
<p>To exclude packets having specific HDMI Packet Types, build an NTV2DIDSet that contains the Packet Types you wish to exclude, then pass the set to <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463" title="Replaces the HDMI packet types to be excluded (filtered) by the given HDMI input&#39;s Aux extractor.">CNTV2Card::AuxExtractSetPacketFilters</a>.</p>
<dl class="section user"><dt>Restoring Default Filtering</dt><dd></dd></dl>
<p>You can also reset the ANC filtering to the default filter set: </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="../../db/de2/ajatypes_8h.html#ae4440931f58d09da66ca92345018fb65">UWord</a> hdmiInput(<a class="code" href="../../db/de2/ajatypes_8h.html#ae4440931f58d09da66ca92345018fb65">UWord</a>(::<a class="code" href="../../d0/d81/ntv2utils_8h.html#a5e144bb8353e29ca6e9e24c5728e07df">GetIndexForNTV2InputSource</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3">NTV2_INPUTSOURCE_HDMI1</a>)));</div>
<div class="line">. . .</div>
<div class="line">NTV2VideoFormat vfmt(device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#acf904ffdd4a560917801add2008528f3">GetInputVideoFormat</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3">NTV2_INPUTSOURCE_HDMI1</a>));</div>
<div class="line">device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463">AuxExtractSetPacketFilters</a>(hdmiInput, AuxExtractGetDefaultDIDs());</div>
</div><!-- fragment --><p>It’s a good practice to save the existing filter settings, change them to what’s needed for whatever processing is necessary, and then restore them afterward: </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line">. . .</div>
<div class="line">const <a class="code" href="../../db/de2/ajatypes_8h.html#ae4440931f58d09da66ca92345018fb65">UWord</a> hdmiInput(<a class="code" href="../../db/de2/ajatypes_8h.html#ae4440931f58d09da66ca92345018fb65">UWord</a>(::<a class="code" href="../../d0/d81/ntv2utils_8h.html#a5e144bb8353e29ca6e9e24c5728e07df">GetIndexForNTV2InputSource</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3">NTV2_INPUTSOURCE_HDMI1</a>)));</div>
<div class="line"><a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#ac815846292eb113e60b58c91ffc67708">NTV2DIDSet</a> savedDIDs;</div>
<div class="line">device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a8ee7a72f5752ae9deff029071e756a28">AuxExtractGetPacketFilters</a>(hdmiInput, savedDIDs);   <span class="comment">// Save current anc filter (so it can be restored later)</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Change the anc filter to include some audio packets...</span></div>
<div class="line">    <a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#ac815846292eb113e60b58c91ffc67708">NTV2DIDSet</a> dids;</div>
<div class="line">    dids.insert(0x01);   <span class="comment">// Audio Clock Regeneration</span></div>
<div class="line">    dids.insert(0x02);   <span class="comment">// Audio Sample (L-PCM &amp; IEC-61937 compressed)</span></div>
<div class="line">    dids.insert(0x84);   <span class="comment">// Audio InfoFrame</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463">AuxExtractSetPacketFilters</a>(hdmiInput, dids);   <span class="comment">// Set new anc filtering</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//  . . . do other processing . . .</span></div>
<div class="line">}</div>
<div class="line">device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463">AuxExtractSetPacketFilters</a>(hdmiInput, savedDIDs);   <span class="comment">// Restore prior anc filtering</span></div>
</div><!-- fragment --><h2><a class="anchor" id="auxcapture-dataspace"></a>
Auxiliary Data Space Limitations</h2>
<p>Rarely does the auxiliary data transmitted with a field of video exceed 5KB (or 10KB for a frame of interlaced video) … but it’s possible. If your application must accommodate more than 72KB of auxiliary data, you’ll need to enlarge the driver’s auxiliary data region.</p>
<p>The NTV2 driver uses two virtual registers (<a class="el" href="../../da/df0/ntv2virtualregisters_8h.html#a5f698dc57a718a4252ef5d121d0863daa74a89fcace7d6a8fb30c2e422a4a03d0" title="Anc Field1 byte offset from end of frame buffer (GUMP on all boards except RTP for SMPTE2022/IP)">kVRegAncField1Offset</a> and <a class="el" href="../../da/df0/ntv2virtualregisters_8h.html#a5f698dc57a718a4252ef5d121d0863daa8e80551da948f37f4a71a3cbdb6ac398" title="Anc Field2 byte offset from end of frame buffer (GUMP on all boards except RTP for SMPTE2022/IP)">kVRegAncField2Offset</a>) to control where the Aux Extractors start writing extracted packet data into (current) frame memory. When the driver starts up, it’s configured to use 0x12000 bytes (~72k) of space per field at the very bottom of each 8MB/16MB/… frame on the device (depending on video format and pixel format).</p>
<p>If you know the largest byte count you’ll encounter for each field, add some padding, then call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad7e9da867ad97b6e7aace1a04b22a54b" title="Sets the capacity of the HDMI AUX buffers in device frame memory.">CNTV2Card::AuxSetFrameBufferSize</a> with those values.</p>
<dl class="section warning"><dt>Warning</dt><dd>Itʼs possible to reserve a very large auxiliary data space that actually runs into the video in the frame buffer.</dd></dl>
<p>To programmatically check if the Aux space intersects video in the frame buffer: </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line">. . .</div>
<div class="line">ULWord byteOffset(0), byteCount(0);</div>
<div class="line"><a class="code" href="../../d6/d0c/ntv2enums_8h.html#ace03c7b6e4f21738519430d1fa42161c">NTV2PixelFormat</a> pixelFormat;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686">NTV2VideoFormat</a> vidFormat(device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#acf904ffdd4a560917801add2008528f3">GetInputVideoFormat</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3">NTV2_INPUTSOURCE_HDMI1</a>));</div>
<div class="line">device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a197831a736299e2c68e3f7f0f860387f">GetFrameBufferFormat</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, pixelFormat);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="../../d3/d4e/class_n_t_v2_format_descriptor.html">NTV2FormatDescriptor</a> fd(vidFormat, pixelFormat);</div>
<div class="line">device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a0ed71a238a94d5d4ed394510a033685d">GetAncRegionOffsetAndSize</a>(byteOffset, byteCount, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a6eef35b2db2fa26fa13a3850c964fdeeadea059bd088f62d28087e81d9bb6be77">NTV2_AncRgn_All</a>);</div>
<div class="line"><span class="keywordflow">if</span> (fd.GetTotalBytes() &gt; byteOffset)</div>
<div class="line">    FAIL(<span class="stringliteral">&quot;HDMI Aux in video!&quot;</span>);</div>
</div><!-- fragment --><dl class="section user"><dt>Maximizing Auxiliary Data Capture Capacity</dt><dd></dd></dl>
<ol type="1">
<li>Determine the largest raster your application is expected to handle.</li>
<li>Determine the most “expensive” (in terms of memory) <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a80edd7ce906ff76d34d139d3b3dbf5f4" title="An alias for NTV2FrameBufferFormat.">NTV2PixelFormat</a> your application will need to use.</li>
<li>Determine the “intrinsic” device frame buffer size that will be used for the video format and frame buffer format (8MB/16MB/etc.).</li>
<li>Calculate the maximum available space for auxiliary data in the device frame buffer. This is the distance, in bytes, from just past the last line of the raster to the bottom of the device frame buffer.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad7e9da867ad97b6e7aace1a04b22a54b" title="Sets the capacity of the HDMI AUX buffers in device frame memory.">CNTV2Card::AuxSetFrameBufferSize</a>, passing half the byte distance to each of the two parameters.</li>
</ol>
<p>For example, 1080i video with a 10-bit YCbCr frame buffer format is easily handled by an 8MB device frame buffer. The 1920x1080 raster occupies the top 5,529,600 bytes of the device frame buffer, which leaves 2,859,008 bytes of space for auxiliary data. If a 16MB frame buffer is used (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a998851c3c5b48e295cd13ae285693b20" title="Sets the device&#39;s intrinsic frame buffer size.">CNTV2Card::SetFrameBufferSize</a>), the maximum possible anc space jumps to 11,247,616 bytes — a <em>LOT</em> of space!</p>
<p>The <a class="el" href="../../db/d02/toolsandutilities.html#inspectorframebuffer">Frame Buffer Inspector</a> of <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> readily illustrates how this works.</p><ol type="1">
<li>Set it to the <b>Raw</b> view mode.</li>
<li>Change the units used for the vertical ruler to <b>Bytes From Top</b>.</li>
<li>Change the units used for the horizontal ruler to <b>Bytes From Left Edge</b>.</li>
<li>Scroll down to the end of active video (EAV). This is where a noticeable boundary between illuminated and dimmed values indicate where changing pixel data ends. That offset – 0x00546000 – is the first safe (unchanging) byte of available HDMI auxiliary buffer space. <div class="image">
<img src="../../watcher-inspector-fb-eav.png" alt=""/>
</div>
</li>
<li>Scroll down further until the data is displayed in a yellow color. That is the HDMI auxiliary data region. <div class="image">
<img src="../../watcher-inspector-fb-ancrgn.png" alt=""/>
</div>
</li>
</ol>
<hr  size="50px" />
<h1><a class="anchor" id="auxplayout"></a>
HDMI Auxiliary Data Playout</h1>
<p>To output HDMI Auxiliary data packets, use HDMI Aux Inserter firmware:</p><ul>
<li>Check <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a03c21b09974ff7b8895282ef5f87be62">CNTV2Card::features</a> ⟹ DeviceCapabilities::CanDoHDMIAuxPlayback returns <code>true</code> to see if HDMI Aux playback is supported.</li>
<li>Auxiliary data packets are automatically inserted into the outgoing video stream when they’ve been properly formatted and placed into a separate area of the device frame buffer.</li>
<li>With <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> :<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a669e0e26f156eacbba892e1520489f5c" title="Prepares for subsequent AutoCirculate playout, designating a contiguous block of frame buffers on the...">CNTV2Card::AutoCirculateInitForOutput</a> with the <a class="el" href="../../d4/dd7/ntv2publicinterface_8h.html#aaf8e112c67edba0b52c9ae9dc4b78427" title="Use this to AutoCirculate with HDMI auxiliary data.">AUTOCIRCULATE_WITH_HDMIAUX</a> option.</li>
<li>Call <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#ad7480e96337587fd0035a42f6d43b17d" title="Sets my ancillary data buffers for use in a subsequent call to CNTV2Card::AutoCirculateTransfer.">AUTOCIRCULATE_TRANSFER::SetAncBuffers</a> to specify the source host Aux buffer(s).</li>
<li>Set the contents of the host Aux buffer(s)…<ul>
<li>Manually write the data — see <a class="el" href="../../d2/d06/auxiliarydata.html#auxbufferformat">HDMI Aux Buffer Data Format</a> (below).</li>
<li>Or use the <a class="el" href="../../de/d4b/ajaanc.html">Ancillary Data Classes</a> — call <a class="el" href="../../d8/def/class_a_j_a_ancillary_list.html#ade6529f821c169268c0a45ec28ac37f3" title="Encodes my AJAAncillaryData packets into the given buffers in the default SDI Anc Buffer Data Format ...">AJAAuxiliaryList::GetTransmitData</a>.</li>
</ul>
</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a>.</li>
</ul>
</li>
<li>Without <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> :<ul>
<li>Configure the HDMI output’s Aux Inserter (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0fe439f828631a30941bed1a5160d5f3" title="Initializes the given HDMI output&#39;s Aux inserter for custom Aux packet insertion.">CNTV2Card::AuxInsertInit</a>, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a82712068a648e49f5eafd873b7da54af" title="Enables or disables the given HDMI output&#39;s Aux inserter frame buffer reads.">CNTV2Card::AuxInsertSetEnable</a>, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ab59c6978950c1fe41d3a9e5933bc1508" title="Configures the Aux inserter for the next frame&#39;s F1 Aux data to embed/transmit.">CNTV2Card::AuxInsertSetReadParams</a>, etc.)</li>
<li>Set the contents of the host Aux buffer(s)…<ul>
<li>Manually write the data — see <a class="el" href="../../d2/d06/auxiliarydata.html#auxbufferformat">HDMI Aux Buffer Data Format</a> (below).</li>
<li>Or use the <a class="el" href="../../de/d4b/ajaanc.html">Ancillary Data Classes</a> to put together an <a class="el" href="../../d6/dc0/ancillarylist_8h.html#a7dab3aeefeaba0fab22c99370f96d2df">AJAAuxiliaryList</a> of packets to send — then call <a class="el" href="../../d8/def/class_a_j_a_ancillary_list.html#ab17ca7eaadca19dd75f779c2118a1755" title="Encodes my AJAAuxiliaryData packets into the given buffers in the default HDMI Aux Buffer Data Format...">AJAAuxiliaryList::GetHDMITransmitData</a>.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3a2464a509352ee85f9a6f393dbd09b2" title="Transfers the contents of the ancillary data buffer(s) from the host to a given frame on the AJA devi...">CNTV2Card::DMAWriteAnc</a>.</li>
</ul>
</li>
</ul>
</li>
<li>Default per-field auxiliary data buffer capacity is 8K by default, or 16K per-frame, including overhead.</li>
</ul>
<p><b>TIP:</b> The <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> tool’s <a class="el" href="../../db/d02/toolsandutilities.html#inspectoranc">Ancillary Data Inspector</a> is useful for diagnosing issues with auxiliary data playout.</p>
<hr  size="50px" />
<h1><a class="anchor" id="auxbufferformat"></a>
HDMI Aux Buffer Data Format</h1>
<p>The data bytes in the auxiliary data buffer consist of zero or more packets. Each packet should have a fixed size of 32 bytes and match this format:</p>
<div class="image">
<img src="../../hdmi_aux_pkt_fmt.png" alt=""/>
</div>
<p>The packet bytes are:</p><ul>
<li>Byte 0: <b>HDMI Packet Type:</b><ul>
<li><b>InfoFrame Packet:</b><ul>
<li><b>0x80:</b> – General InfoFrame Packet (might be invalid)</li>
<li><b>0x81:</b> – Vendor-Specific InfoFrame</li>
<li><b>0x82:</b> – AVI InfoFrame</li>
<li><b>0x83:</b> – Source Product Descriptor InfoFrame</li>
<li><b>0x84:</b> – Audio InfoFrame</li>
<li><b>0x85:</b> – MPEG Source InfoFrame</li>
</ul>
</li>
<li><b>Other Packet:</b><ul>
<li><b>0x01:</b> – Audio Clock Regeneration (N/CTS)</li>
<li><b>0x02:</b> – Audio Sample (L-PCM &amp; IEC-61937 compressed)</li>
<li><b>0x03:</b> – General Control</li>
<li><b>0x04:</b> – ACP Packet</li>
<li><b>0x05:</b> – ISRC1 Packet</li>
<li><b>0x06:</b> – ISRC2 Packet</li>
<li><b>0x07:</b> – One Bit Audio Sample Packet</li>
<li><b>0x08:</b> – DST Audio Packet</li>
<li><b>0x09:</b> – High Bitrate Audio Stream Packet (IEC-61937)</li>
<li><b>0x0A:</b> – Gamut Metadata Packet</li>
</ul>
</li>
</ul>
</li>
<li>Byte 1: <b>Header Byte 1</b> (<code>HB1</code>)</li>
<li>Byte 2: <b>Header Byte 2</b> (<code>HB2</code>)<ul>
<li>For <b>InfoFrame</b>s, the least-significant 5 bits of this byte contains the actual packet payload size, in bytes.</li>
</ul>
</li>
<li>Byte 3:<ul>
<li>For <b>InfoFrame</b>s, this byte stores the packet checksum;</li>
<li>For all other packets, this is the first payload data byte.</li>
</ul>
</li>
<li>Byte 4:<ul>
<li>For <b>InfoFrame</b>s, this byte stores the first payload data byte.</li>
<li>For all other packets, this is the 2nd payload data byte.</li>
</ul>
</li>
<li>Bytes 5 …&#160;31: Remaining payload data bytes</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>During playback/output, before transferring the F1 (or F2 for interlace) aux buffer from the host, it’s a good practice to truncate (or zero) the buffer at (or past) the last packet written into the buffer.</dd>
<dd>
During capture/input, after transferring the F1 (or F2 for interlace) aux buffer to the host, it’s a good practice to query the actual number of bytes written by the HDMI Aux Extractor, then truncate (or zero) the remainder of the host aux buffer with zeroes, to prevent parsing of stale/invalid aux packet data.</dd></dl>
<p>For <b>Capture</b>:</p><ul>
<li>Clients can parse the data themselves, using the above specification.</li>
<li><a class="el" href="../../d8/def/class_a_j_a_ancillary_list.html#a7a2f425d823df9f88934bacf2130213b" title="Returns all ancillary data packets found in the given F1 and F2 ancillary data buffers.">AJAAuxiliaryList::SetFromDeviceAncBuffers</a> can be called to transform the buffer contents into an <a class="el" href="../../d6/dc0/ancillarylist_8h.html#a7dab3aeefeaba0fab22c99370f96d2df">AJAAuxiliaryList</a> containing one <a class="el" href="../../d7/d92/ancillarydata_8h.html#a2c180fa75e261e39b0691fe2326c20fe">AJAAuxiliaryData</a> instance per packet.</li>
</ul>
<p>For <b>Playout</b>:</p><ul>
<li>Clients can write the data themselves per the above specification.</li>
<li><a class="el" href="../../d8/def/class_a_j_a_ancillary_list.html#ade6529f821c169268c0a45ec28ac37f3" title="Encodes my AJAAncillaryData packets into the given buffers in the default SDI Anc Buffer Data Format ...">AJAAuxiliaryList::GetTransmitData</a> can be called to fill your Aux playout buffers from an <a class="el" href="../../d6/dc0/ancillarylist_8h.html#a7dab3aeefeaba0fab22c99370f96d2df">AJAAuxiliaryList</a>.<ul>
<li>If using <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> , these buffers can be transferred to the AJA device by first calling <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#ad7480e96337587fd0035a42f6d43b17d" title="Sets my ancillary data buffers for use in a subsequent call to CNTV2Card::AutoCirculateTransfer.">AUTOCIRCULATE_TRANSFER::SetAncBuffers</a> , then calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a>.</li>
<li>If not using AutoCirculate, the buffers can be transferred to the AJA device using <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3a2464a509352ee85f9a6f393dbd09b2" title="Transfers the contents of the ancillary data buffer(s) from the host to a given frame on the AJA devi...">CNTV2Card::DMAWriteAnc</a>. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclass_n_t_v2_format_descriptor_html"><div class="ttname"><a href="../../d3/d4e/class_n_t_v2_format_descriptor.html">NTV2FormatDescriptor</a></div><div class="ttdoc">Describes a video frame for a given video standard or format and pixel format, including the total nu...</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/df4/ntv2formatdescriptor_8h_source.html#l00041">ntv2formatdescriptor.h:41</a></div></div>
<div class="ttc" id="antv2enums_8h_html_ace03c7b6e4f21738519430d1fa42161c"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#ace03c7b6e4f21738519430d1fa42161c">NTV2FrameBufferFormat</a></div><div class="ttdeci">NTV2FrameBufferFormat</div><div class="ttdoc">Identifies a particular video frame buffer format. See Device Frame Buffer Formats for details.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l00210">ntv2enums.h:210</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a></div><div class="ttdeci">@ NTV2_CHANNEL1</div><div class="ttdoc">Specifies channel or FrameStore 1 (or the first item).</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01345">ntv2enums.h:1345</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a197831a736299e2c68e3f7f0f860387f"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a197831a736299e2c68e3f7f0f860387f">CNTV2Card::GetFrameBufferFormat</a></div><div class="ttdeci">virtual bool GetFrameBufferFormat(NTV2Channel inChannel, NTV2FrameBufferFormat &amp;outValue)</div><div class="ttdoc">Returns the current frame buffer format for the given FrameStore on the AJA device.</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l01875">ntv2register.cpp:1875</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a0ed71a238a94d5d4ed394510a033685d"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a0ed71a238a94d5d4ed394510a033685d">CNTV2Card::GetAncRegionOffsetAndSize</a></div><div class="ttdeci">virtual bool GetAncRegionOffsetAndSize(ULWord &amp;outByteOffset, ULWord &amp;outByteCount, const NTV2AncillaryDataRegion inAncRegion=NTV2_AncRgn_All)</div><div class="ttdoc">Answers with the offset and size of an ancillary data region within a device frame buffer.</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/d53/ntv2dma_8cpp_source.html#l00516">ntv2dma.cpp:516</a></div></div>
<div class="ttc" id="antv2utils_8h_html_a5e144bb8353e29ca6e9e24c5728e07df"><div class="ttname"><a href="../../d0/d81/ntv2utils_8h.html#a5e144bb8353e29ca6e9e24c5728e07df">GetIndexForNTV2InputSource</a></div><div class="ttdeci">ULWord GetIndexForNTV2InputSource(const NTV2InputSource inValue)</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d9b/ntv2utils_8cpp_source.html#l05339">ntv2utils.cpp:5339</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a8ee7a72f5752ae9deff029071e756a28"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a8ee7a72f5752ae9deff029071e756a28">CNTV2Card::AuxExtractGetPacketFilters</a></div><div class="ttdeci">virtual bool AuxExtractGetPacketFilters(const UWord inHDMIInput, NTV2DIDSet &amp;outDIDs)</div><div class="ttdoc">Answers with the HDMI packet types currently being excluded (filtered) by the HDMI input's Aux extrac...</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/dc5/ntv2aux_8cpp_source.html#l00860">ntv2aux.cpp:860</a></div></div>
<div class="ttc" id="aajatypes_8h_html_ae4440931f58d09da66ca92345018fb65"><div class="ttname"><a href="../../db/de2/ajatypes_8h.html#ae4440931f58d09da66ca92345018fb65">UWord</a></div><div class="ttdeci">uint16_t UWord</div><div class="ttdef"><b>Definition:</b> <a href="../../db/de2/ajatypes_8h_source.html#l00253">ajatypes.h:253</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a></div><div class="ttdoc">I interrogate and control an AJA video/audio capture/playout device.</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d4b/ntv2card_8h_source.html#l00028">ntv2card.h:28</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a1e15dbfa3365997a5d98392387e00463"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a1e15dbfa3365997a5d98392387e00463">CNTV2Card::AuxExtractSetPacketFilters</a></div><div class="ttdeci">virtual bool AuxExtractSetPacketFilters(const UWord inHDMIInput, const NTV2DIDSet &amp;inDIDs)</div><div class="ttdoc">Replaces the HDMI packet types to be excluded (filtered) by the given HDMI input's Aux extractor.</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/dc5/ntv2aux_8cpp_source.html#l00886">ntv2aux.cpp:886</a></div></div>
<div class="ttc" id="antv2enums_8h_html_ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3">NTV2_INPUTSOURCE_HDMI1</a></div><div class="ttdeci">@ NTV2_INPUTSOURCE_HDMI1</div><div class="ttdoc">Identifies the 1st HDMI video input.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01256">ntv2enums.h:1256</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_acf904ffdd4a560917801add2008528f3"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#acf904ffdd4a560917801add2008528f3">CNTV2Card::GetInputVideoFormat</a></div><div class="ttdeci">virtual NTV2VideoFormat GetInputVideoFormat(const NTV2InputSource inVideoSource=NTV2_INPUTSOURCE_SDI1, const bool inIsProgressive=(0))</div><div class="ttdoc">Returns the video format of the signal that is present on the given input source.</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l03365">ntv2register.cpp:3365</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a8f85ca8efb8928620e1fbb6282a5e686"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686">NTV2VideoFormat</a></div><div class="ttdeci">enum _NTV2VideoFormat NTV2VideoFormat</div><div class="ttdoc">Identifies a particular video format.</div></div>
<div class="ttc" id="antv2publicinterface_8h_html_ac815846292eb113e60b58c91ffc67708"><div class="ttname"><a href="../../d4/dd7/ntv2publicinterface_8h.html#ac815846292eb113e60b58c91ffc67708">NTV2DIDSet</a></div><div class="ttdeci">std::set&lt; UByte &gt; NTV2DIDSet</div><div class="ttdoc">A set of distinct NTV2DID values.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dd7/ntv2publicinterface_8h_source.html#l00076">ntv2publicinterface.h:76</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a6eef35b2db2fa26fa13a3850c964fdeeadea059bd088f62d28087e81d9bb6be77"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a6eef35b2db2fa26fa13a3850c964fdeeadea059bd088f62d28087e81d9bb6be77">NTV2_AncRgn_All</a></div><div class="ttdeci">@ NTV2_AncRgn_All</div><div class="ttdoc">Identifies &quot;all&quot; ancillary data regions.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l04206">ntv2enums.h:4206</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">The NTV2 SDK</a></li>
    <li class="footer">Generated on Wed Jan 22 2025 19:07:49 for AJA NTV2 SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
