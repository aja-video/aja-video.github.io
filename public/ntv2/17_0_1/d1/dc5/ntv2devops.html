<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AJA NTV2 SDK: NTV2 Device Hardware Operation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../ajastyles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../AJALogoMini.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AJA NTV2 SDK
   &#160;<span id="projectnumber">17.0.1.1246</span>
   </div>
   <div id="projectbrief">NTV2 SDK 17.0.1.1246</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d1/dc5/ntv2devops.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">NTV2 Device Hardware Operation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>On this page:</p><ul>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#ntv2devops-intro">Introduction</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#devicesignalinputsoutputs">Signal Inputs &amp; Outputs</a><ul>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#commonelectricalchars">Common Electrical Characteristics</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#hwcharacteristics">Hardware Characteristics</a></li>
</ul>
</li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#videooperation">Video System Operation</a><ul>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fs">FrameStore Operation</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#independentmode">Multi-Format / “Independent” Mode</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fbaccess">Frame Buffer Access</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#deviceclockingandsync">Device Clocking and Synchronization</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#fieldframeinterrupts">Field/Frame Interrupts</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fbconflict">When FrameStores Access the Same Frame Buffer Memory</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#vidop-csc">Color Space Converter Operation</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#vidop-lut">LUT Operation</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#vidop-mixerkeyer">Mixer/Keyer Operation</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#vidop-hdr">High Dynamic Range (HDR) Video</a></li>
</ul>
</li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#audiooperation">Audio System Operation</a><ul>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#audiocapture">Audio Capture</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#audioplayout">Audio Playout</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#audiosamplecount">Correlating Audio Samples to Video Frames</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#audiohidden">“Hidden” Audio Systems</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#audioclobber">Audio Buffer Corruption</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#audiomixer">Audio Mixer</a></li>
</ul>
</li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#devicefirmware">Firmware</a><ul>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#dev-firmware-loading">Loading Firmware</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#dev-firmware-flash">“Flashing” Firmware</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#dev-firmware-vers">Determining Firmware Version</a></li>
<li><a class="el" href="../../d1/dc5/ntv2devops.html#dev-firmware-features">Determining Firmware Features</a></li>
</ul>
</li>
</ul>
<hr  size="50px" />
 <h1><a class="anchor" id="ntv2devops-intro"></a>
Introduction</h1>
<p>In simplest terms, NTV2 devices are essentially…</p><ul>
<li>a big chunk of SDRAM memory for buffering video frames and audio samples, which is tied to…</li>
<li>an FPGA that determines what gets written or read to/from that memory (and where), plus…</li>
<li>one or more video and/or audio signal inputs and/or outputs, and…</li>
<li>a high-speed PCIe interface to a host computer, for rapidly reading or writing 32-bit registers, and transferring bulk data via DMA to/from the host.</li>
</ul>
<div class="image">
<img src="../../hwref-fig0-blockdiagram.png" alt=""/>
</div>
<p>In addition, the FPGA firmware implements “widgets“ that can process video data in a particular way (e.g., color correction, muxing/demuxing, etc.).</p>
<p>All AJA NTV2 hardware devices minimally support the following:</p><ul>
<li>Capture or play to/from the host computer video and audio through at least one video connector.</li>
<li>SD video formats: 525i 59.94fps, and 625i 50fps</li>
<li>HD video formats: 720p 50/59.94/60, 1080i 50/59.94/60, 1080psf 23.98/24 and 1080p 23.98/24/29.97/30</li>
<li>8-bit YCbCr or 10-bit YCbCr frame buffer formats.</li>
</ul>
<p>Beyond these common characteristics, AJA devices fan out into a diverse array of capabilities to suit many different applications. To determine the features of an AJA device, use the <b>Device Features API</b> in the <a class="el" href="../../d7/dce/ajantv2.html">“libajantv2” Class Library</a> .</p>
<p>Most devices can capture and play video, but some may only capture, while others may only playout.</p><ul>
<li>To determine if a device can capture video, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ab5189daf688987b280922fb6cde1466f">NTV2DeviceCanDoCapture</a>.</li>
<li>To determine if a device can play video, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a2a59728d0474fc70c9887b81eecad127">NTV2DeviceCanDoPlayback</a>.</li>
</ul>
<hr  size="50px" />
 <h1><a class="anchor" id="devicesignalinputsoutputs"></a>
Signal Inputs &amp; Outputs</h1>
<dl class="section user"><dt>Breakout Boxes and Cables</dt><dd></dd></dl>
<p>On some devices, certain signal connectors are accessible only through a breakout cable or breakout box.</p><ul>
<li>To determine if the device can support a breakout box, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a65a3b8207806dc5f4f54c5b011489c9d">NTV2DeviceCanDoBreakoutBox</a>.</li>
<li>To determine if a breakout box is connected, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1b1f47bac65286af74f64dc68475383c">CNTV2Card::GetBreakoutHardware</a>.</li>
</ul>
<dl class="section user"><dt>SDI Connectors</dt><dd></dd></dl>
<p>Most AJA devices have at least one SDI connector.</p><ul>
<li>To determine the number of SDI input jacks the device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ae8ebf28296f938a87237456a4a6866e0">NTV2DeviceGetNumVideoInputs</a>.</li>
<li>To determine the number of SDI output jacks the device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a1c7b90df5e62610074a95589224057af">NTV2DeviceGetNumVideoOutputs</a>.</li>
</ul>
<p>Some SDI connectors are permanently configured as inputs, others as outputs, but on some devices, they’re software-configurable. This means your application can instruct the device to reconfigure one of its SDI jacks from an input to an output (or vice-versa).</p><ul>
<li>To determine if a device has software-configurable SDI connectors, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#add0bea97e5bae91256afa64381ff57de">NTV2DeviceHasBiDirectionalSDI</a>.</li>
<li>If a device has bi-directional SDI connectors, the <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ae8ebf28296f938a87237456a4a6866e0">NTV2DeviceGetNumVideoInputs</a> and <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a1c7b90df5e62610074a95589224057af">NTV2DeviceGetNumVideoOutputs</a> will reflect the maximum possible number of inputs and outputs.<ul>
<li>For example, the <a class="el" href="../../d0/d53/ntv2devices.html#io4kquad">Io4K (Quad Mode)</a> has four bi-directional SDI jacks plus an additional monitor (output-only) jack, so for that device, <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ae8ebf28296f938a87237456a4a6866e0">NTV2DeviceGetNumVideoInputs</a> returns 4 and <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a1c7b90df5e62610074a95589224057af">NTV2DeviceGetNumVideoOutputs</a> returns 5.</li>
</ul>
</li>
<li>To determine if an SDI connector is currently configured to transmit, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aeddc6651baf5ad443a9487e05e285462" title="Answers whether or not the specified SDI connector is currently acting as a transmitter (i....">CNTV2Card::GetSDITransmitEnable</a>.</li>
<li><p class="startli">To change an SDI connector’s function to receive or transmit, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe" title="Sets the specified bidirectional SDI connector to act as an input or an output.">CNTV2Card::SetSDITransmitEnable</a>.</p>
<dl class="section note"><dt>Note</dt><dd>When changing an SDI connector from ‘transmit’ to ‘receive’, it can take a while for the device input to lock to the incoming signal (when there is one). It’s best to delay several frames (or more) before calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a30cb1b93e67f00ea6ed72dba5747de27" title="Returns the video format of the signal that is present on the given input source.">CNTV2Card::GetInputVideoFormat</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a87679efa4d23f3528b7034df086a4f53" title="Returns the video format of the signal that is present on the given SDI input source.">CNTV2Card::GetSDIInputVideoFormat</a> to obtain an accurate determination of what signal is present.</dd></dl>
<p>All SDI connectors on NTV2 devices can receive or transmit 1.5 Gbps signals, and almost all will handle 3Gbps.</p>
</li>
<li>To determine if its SDI spigots can handle 6Gbps or 12Gbps, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a6d3b9ebaa05ad97db18040212dc8b557">NTV2DeviceCanDo12GSDI</a>.</li>
</ul>
<p>To determine if there’s a signal present at an SDI input connector, and if so, what format it is…</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a30cb1b93e67f00ea6ed72dba5747de27" title="Returns the video format of the signal that is present on the given input source.">CNTV2Card::GetInputVideoFormat</a>, specifying an <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1" title="Identifies a specific video input source.">NTV2InputSource</a> …<ul>
<li>Use <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1a703adbb510b0143ec922f8d7c2f02b40" title="Identifies the 1st SDI video input.">NTV2_INPUTSOURCE_SDI1</a>, <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1a2275885d150dab8471c7e117954ac981" title="Identifies the 2nd SDI video input.">NTV2_INPUTSOURCE_SDI2</a>, etc.</li>
<li>Or use the result of <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#a5ff8b72d2b6eb93a76bd050ff947f80e">GetNTV2InputSourceForIndex</a>.</li>
</ul>
</li>
<li>Or call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a87679efa4d23f3528b7034df086a4f53" title="Returns the video format of the signal that is present on the given SDI input source.">CNTV2Card::GetSDIInputVideoFormat</a>, specifying the SDI input connector as an <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dce" title="These enum values are mostly used to identify a specific Frame Store. They&#39;re also commonly used to i...">NTV2Channel</a> value.</li>
<li>Whichever function you use, if you are expecting <b>psf</b> video, pass ‘true’ for the ‘<em>inIsProgressive</em>’ parameter.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>On rare occasion, some SDI devices emit non-compliant SDI containing bad CRC values. Newer AJA NTV2 firmware ignores input CRCs when detecting TRS, to enable such non-compliant signals to still be captured.</dd></dl>
<dl class="section user"><dt>HDMI Connectors</dt><dd></dd></dl>
<p>Many AJA devices have HDMI connectors, some for capture, most for playout.</p><ul>
<li>To determine the number of HDMI inputs the device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#af96e09b54769bd2e8c35b5b85aa45b0e">NTV2DeviceGetNumHDMIVideoInputs</a>.</li>
<li>To determine the number of HDMI outputs the device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#aef10706f5b1fc8d00d810c6d664d3d59">NTV2DeviceGetNumHDMIVideoOutputs</a>.</li>
<li>HDMI capabilities depend on the physical HDMI hardware used on the device and the supporting firmware. To determine which HDMI hardware is present on the device, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a3eb1ff4f43aba95f9e75c7c78f155366">NTV2DeviceGetHDMIVersion</a>. (Note that this doesn’t return an HDMI protocol version — it’s strictly an unsigned integer that indicates which “generation” of HDMI hardware was used on the device.</li>
<li>HDMI hardware capabilities chart:</li>
</ul>
<div class="image">
<img src="../../hdmichart.png" alt=""/>
</div>
<p>To determine if there’s a signal present at an HDMI input connector, and if so, what format it is…</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a30cb1b93e67f00ea6ed72dba5747de27" title="Returns the video format of the signal that is present on the given input source.">CNTV2Card::GetInputVideoFormat</a>, specifying an <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1" title="Identifies a specific video input source.">NTV2InputSource</a> …<ul>
<li>Use <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1add6273c6b6f1879a1da1f6e84bf074d3" title="Identifies the 1st HDMI video input.">NTV2_INPUTSOURCE_HDMI1</a>, <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1a2c95041082ce07d47b256832c29afcef" title="Identifies the 2nd HDMI video input.">NTV2_INPUTSOURCE_HDMI2</a>, etc.</li>
<li>Or use the result of <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#a5ff8b72d2b6eb93a76bd050ff947f80e">GetNTV2InputSourceForIndex</a> — specify <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a249aca7f07e610b1b9f65868a156c0c0ac6c0e89d4e33770f858cfe0b0d4a7cec">NTV2_INPUTSOURCES_HDMI</a> for the ‘<em>inKinds</em>’ parameter.</li>
<li>If you are expecting <b>psf</b> video, pass ‘true’ for the ‘<em>inIsProgressive</em>’ parameter.</li>
</ul>
</li>
<li>Or call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af71c11141d729fcd3ee511cef2d18c08">CNTV2Card::GetHDMIInputVideoFormat</a>, specifying the HDMI input connector as an <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dce" title="These enum values are mostly used to identify a specific Frame Store. They&#39;re also commonly used to i...">NTV2Channel</a> value.</li>
<li>If a DVI monitor is connected to the HDMI output connector, no audio will be transmitted (since DVI doesnʼt support audio).</li>
<li>If an HDMI monitor is connected to the HDMI output connector, and it appears to be “DVI”, this is often caused by the firmware not correctly reading the monitor configuration (EDID), so it falls back to DVI. To force the HDMI output to HDMI:<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3e82c730faf759989f8cf1489151e97d">CNTV2Card::SetHDMIOutProtocol</a> and specify <code>NTV2_HDMIProtocolHDMI</code>, and…</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#acb9788f67a55b5aa33c4a83d04c03851">CNTV2Card::SetHDMIOutForceConfig</a> and specify <code>true</code>.</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Analog Video Connectors</dt><dd></dd></dl>
<p>Some older AJA devices have analog video connectors (remember the old RCA component-level jacks?).</p><ul>
<li>To determine the number of analog video inputs the device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a0d29f053b83e46bb23f289615d4a1cd1">NTV2DeviceGetNumAnalogVideoInputs</a>.</li>
<li>To determine the number of analog video outputs the device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ab150316f235d6aa708f3cb6480a72f0b">NTV2DeviceGetNumAnalogVideoOutputs</a>.</li>
</ul>
<p>To determine if there’s a signal present at an analog video input connector, and if so, what format it is…</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a30cb1b93e67f00ea6ed72dba5747de27" title="Returns the video format of the signal that is present on the given input source.">CNTV2Card::GetInputVideoFormat</a>, specifying an <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1" title="Identifies a specific video input source.">NTV2InputSource</a> …<ul>
<li>Use <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac5dbe58ce5dcc94682e0012abc6124f1a296bc825aebaf870b9f8990b7e2e89a3" title="Identifies the first analog video input.">NTV2_INPUTSOURCE_ANALOG1</a>.</li>
<li>Or use the result of <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#a5ff8b72d2b6eb93a76bd050ff947f80e">GetNTV2InputSourceForIndex</a> — specify <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a249aca7f07e610b1b9f65868a156c0c0a85fc12e3468c4ef31b5607126b5cf480">NTV2_INPUTSOURCES_ANALOG</a> for the ‘<em>inKinds</em>’ parameter.</li>
<li>If you are expecting <b>psf</b> video, pass ‘true’ for the ‘<em>inIsProgressive</em>’ parameter.</li>
</ul>
</li>
<li>Or call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a47064964be2b42c866d248a57d409c3d" title="Returns the video format of the signal that is present on the device&#39;s analog video input.">CNTV2Card::GetAnalogInputVideoFormat</a>.</li>
</ul>
<dl class="section user"><dt>Audio Connectors</dt><dd></dd></dl>
<p>Some AJA devices have separate connectors for audio input and/or output, even analog audio on some older devices.</p><ul>
<li>To determine if the device is capable of analog audio input or output, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a6d2215a599ae62b06c61171bfd09fef4">NTV2DeviceCanDoAnalogAudio</a>.</li>
<li>To determine how many AES inputs and/or outputs a device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#adbfb5ea117a5b40ce127529a7573aa9d">NTV2DeviceGetNumAESAudioInputChannels</a> and/or <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ac0cb51e349cd5d7a323da96e5a51c0c8">NTV2DeviceGetNumAESAudioOutputChannels</a>, respectively.</li>
<li>To determine how many analog audio inputs and/or outputs a device has, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a5f102a5e31c734658c3dbceba84738da">NTV2DeviceGetNumAnalogAudioInputChannels</a> and/or <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a75ff73bfda8289762b0a60d6b45655bb">NTV2DeviceGetNumAnalogAudioOutputChannels</a>, respectively.</li>
</ul>
<dl class="section user"><dt>Reference and LTC Connectors</dt><dd></dd></dl>
<p>Most AJA devices have a single BNC connector that can be used for reference input or for analog LTC input. On other devices, there are separate reference and LTC input connectors. Some devices have output connectors for LTC or Reference.</p><ul>
<li>To determine the number of reference video inputs, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a43b972ed23192429f87c40bf7cee2b19">NTV2DeviceGetNumReferenceVideoInputs</a>.</li>
<li>To determine the number of LTC inputs, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a2531be66d3eb0f62b1fa362b35182cac">NTV2DeviceGetNumLTCInputs</a>.</li>
<li>To determine if the device can be configured to receive LTC on its reference input port, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ad4ca87b50cb52c351c69ce2a95c8b804">NTV2DeviceCanDoLTCInOnRefPort</a>. If the device can receive LTC from its Reference input…<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aa0528df207ce414f0bbf9bb2cebf4edb" title="Answers true if the device is currently configured to read analog LTC from the reference input connec...">CNTV2Card::GetLTCInputEnable</a> to determine if the input is configured to receive analog LTC from its Reference port.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a4dca4f7dbf9496f65e6e4154117aac2d" title="Enables or disables the ability for the device to read analog LTC on the reference input connector.">CNTV2Card::SetLTCInputEnable</a> to configure the Reference/LTC input: pass <b>true</b> to have it receive analog LTC; pass <b>false</b> to have it receive Reference.</li>
</ul>
</li>
<li>To determine if a valid LTC signal is present at the connector, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac1cb0716a6edab2c96f71271a487118f" title="Answers whether or not a valid analog LTC signal is being applied to the device&#39;s analog LTC input co...">CNTV2Card::GetLTCInputPresent</a>.</li>
<li>To determine the number of LTC outputs, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ad744bcd8136c31703a6edcc7930d5d40">NTV2DeviceGetNumLTCOutputs</a>.</li>
</ul>
<dl class="section user"><dt>Serial Ports (RS-422)</dt><dd></dd></dl>
<p>Most AJA devices have a single RS-422 connector that can be used to control tape deck transports and for other purposes.</p><ul>
<li>To determine the number of serial ports on a device, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#afc493740592804442187ff521df0968f">NTV2DeviceGetNumSerialPorts</a>.</li>
<li>To determine if the serial port is programmable (for baud rate, parity, etc.), call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a130a4f011f989382d984cf2b5ab781f4">NTV2DeviceCanDoProgrammableRS422</a>.<ul>
<li>To determine the current baud rate, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2bb07ab55e063b96f14bfaf93d34eb21" title="Answers with the current baud rate of the specified RS422 serial port.">CNTV2Card::GetRS422BaudRate</a>. To change the baud rate, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1c4e8be8766fbfedd128891b3a32e149" title="Sets the baud rate of the specified RS422 serial port.">CNTV2Card::SetRS422BaudRate</a>.</li>
<li>To determine the current parity configuration, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0645149b53c3650f09fdcbc7e4a40097" title="Answers with the current parity control for the specified RS422 serial port.">CNTV2Card::GetRS422Parity</a>. To change the baud rate, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a5cd41a98ab45f157de8d02fbf8f4174d" title="Sets the parity control on the specified RS422 serial port.">CNTV2Card::SetRS422Parity</a>.</li>
</ul>
</li>
</ul>
<div class="image">
<img src="../../rs422pinout400.png" alt=""/>
</div>
<h2><a class="anchor" id="commonelectricalchars"></a>
Common Electrical Characteristics</h2>
<p>Unless otherwise noted, physical and electrical characteristics of inputs and outputs — SDI, HDMI, analog video, analog audio, reference, LTC, etc. — are generally identical across all AJA devices.</p>
<p><b>SDI Input(s)</b></p><ul>
<li>AC-coupled input terminated with 75Ω to ground</li>
<li>SMPTE 292 compliant — 800mV peak-to-peak ±10%</li>
</ul>
<p><b>SDI Output(s)</b></p><ul>
<li>AC-coupled output terminated with 75Ω to ground</li>
<li><b>Output Level:</b> 800mV peak-to-peak ±10%, terminated into 75Ω</li>
</ul>
<p><b>Video Reference Input(s)</b></p><ul>
<li>Analog video reference, NTSC, PAL, or tri-level sync</li>
<li>Input terminated by 75Ω to ground</li>
<li><b>Input level:</b> 0.5 Volts peak-to-peak to 2.0 Volts peak-to-peak</li>
<li>Tri-level sync:<ul>
<li>Analog Color Black (700 mV sync nominal, plus burst)</li>
<li>Composite Sync (700 mV sync nominal, plus burst and video)</li>
<li>HD Tri-Level Sync (±700 mV sync)</li>
</ul>
</li>
</ul>
<p><b>Analog LTC Input(s)</b></p><ul>
<li>Designed to work with inverted or non-inverted inputs</li>
<li>Input impedence 75Ω, coax or other single-ended connection is recommended</li>
<li>There is no differential termination on these inputs, so a balanced connection may not be reliable</li>
<li>Designed to meet SMPTE spec, 0.5V to 4.5Vp-p</li>
</ul>
<p><b>HDMI Input, Output</b></p><ul>
<li>Connector: Type-A (unless otherwise noted)</li>
</ul>
<p><b>AES Input(s)</b></p><ul>
<li>DC-coupled input terminated with 75Ω to ground</li>
<li><b>Minimum input level:</b> 100 mV peak-to-peak</li>
</ul>
<p><b>AES Output(s)</b></p><ul>
<li>AC-coupled output terminated with 75Ω to ground</li>
<li><b>Output level:</b> 1.55 Volts peak-to-peak, +/- 10%, terminated into 75Ω</li>
</ul>
<p><b>Analog Video Output(s)</b></p><ul>
<li>12-bit precision DAC output</li>
<li><b>Luma Bandwidth:</b> 12.5 MHz (SD) or 30 MHz (HD)</li>
<li><b>Chroma Bandwidth:</b> 5.8 MHz (SD) or 13.75 MHz (HD)</li>
</ul>
<p><b>Audio Output</b></p><ul>
<li><b>Connector:</b> DB-25</li>
<li><b>Maximum Level, unclipped:</b> +12dBu, +15dBu, +18dBu, +24dBu (selectable)</li>
</ul>
<h2><a class="anchor" id="hwcharacteristics"></a>
Hardware Characteristics</h2>
<dl class="section user"><dt>PCI Interface</dt><dd></dd></dl>
<p>All NTV2 devices utilize Peripheral Component Interconnect (PCI) or Peripheral Component Interconnect Express (PCIe) to communicate with the host computer system (or with other PCI/PCIe peers on the same host).</p>
<dl class="section user"><dt>PCI Vendor ID</dt><dd></dd></dl>
<p>All AJA NTV2 devices have the same PCI vendor ID.</p><ul>
<li>PCI vendor ID: <b><code>0xF1D0</code></b></li>
</ul>
<dl class="section user"><dt>Data Transfer</dt><dd></dd></dl>
<p>Direct Memory Access (DMA) is the only supported method of moving data between host memory and the hardware. All NTV2 devices have at least one DMA engine. (Programmed Input/Output, a.k.a. PIO is no longer supported.)</p><ul>
<li>To determine the number of DMA engines for a device, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a31e522741edab8ed4a0542a1b1d00763">NTV2DeviceGetNumDMAEngines</a>.</li>
</ul>
<dl class="section user"><dt>Device Frame Buffer</dt><dd></dd></dl>
<p>All NTV2 devices have a fixed amount of Synchronous Dynamic Random Access Memory (SDRAM). The FPGA is the SDRAM controller, which controls the output of video (and metadata, such as audio and anc) from RAM, the input of video (and metadata) into RAM, the PCI interface to/from RAM, and RAM refresh.</p>
<dl class="section user"><dt>Frame Buffer Layout</dt><dd></dd></dl>
<p>The FPGA is programmed with firmware that implements a number of video I/O and signal-processing “widgets”, plus other programming to handle other signal and data I/O.</p><ul>
<li>The device’s SDRAM is logically partitioned into a number of equal-sized <b>frames</b>.</li>
<li>The intrinsic <b>frame size</b> used for <a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fbindexing">Frame Buffer Indexing</a> defaults to 8MB (and is doubled when necessary).</li>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a4c829f30c5602163d455999d7b358eb4">NTV2DeviceGetActiveMemorySize</a> to discover a device’s SDRAM complement.</li>
</ul>
<div class="image">
<img src="../../hwref-fig1-sdramfblayout.png" alt=""/>
</div>
<p>The vast majority of the SDRAM frames are used for storing video raster data.</p>
<p>Audio ring buffer storage is located at the very top of SDRAM. As such, the uppermost frame(s) should be avoided for video. See <a class="el" href="../../d1/dc5/ntv2devops.html#audiooperation">Audio System Operation</a> for more information.</p>
<p>Video data in the device frame buffer is always stored full-frame. Interlaced video is always stored in the frame buffer with the first line of Field 1 (F1L1) at the top of the buffer, followed by the first line of Field 2 (F2L1), then F1L2, F2L2, F1L3, F2L3, etc., alternating to the end of the frame. An exception to this is NTSC SD 525i, which starts with Field 2 at the top of the buffer (F2L1, F1L1, F2L2, F1L2, etc.).</p>
<dl class="section note"><dt>Note</dt><dd>A very <em>very</em> long time ago, AJA had devices that stored all of F1’s lines in the top half of the buffer, and all of F2’s lines in the bottom half. These devices and buffer formats are no longer supported.</dd></dl>
<p>See <a class="el" href="../../d1/dc5/ntv2devops.html#videooperation">Video System Operation</a> for more details.</p>
<hr  size="50px" />
 <h1><a class="anchor" id="videooperation"></a>
Video System Operation</h1>
<p>This section describes how the Video System operates.</p>
<h2><a class="anchor" id="vidop-fs"></a>
FrameStore Operation</h2>
<p>A <b>FrameStore</b> is a device widget implemented in FPGA firmware that writes or reads video data to or from SDRAM, depending upon its mode (capture or playback), and uses several registers to control its operation. Each <b>FrameStore</b> has the following properties:</p><ul>
<li><b>Enable/Disable State</b> — When <b>Disabled</b>, the widget cannot access SDRAM. Disabling unnecessary SDRAM access reduces memory accesses and can thereby improve performance.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad7ab43c1f7d53cc2f073b15048146723" title="Answers whether or not the given FrameStore is enabled.">CNTV2Card::IsChannelEnabled</a> to determine if a <b>FrameStore</b> is enabled or not.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77" title="Enables the given FrameStore.">CNTV2Card::EnableChannel</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad7b7b304fea36b3323f1fb2c75fbf69b" title="Disables the given FrameStore.">CNTV2Card::DisableChannel</a> to change it.</li>
<li>If <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> is used, the <b>FrameStore</b> is automatically enabled when needed (but it’s not automatically disabled after use).</li>
</ul>
</li>
<li><b>Mode</b> — This correlates to the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5" title="Used to identify the mode of a Frame Store, or the direction of an AutoCirculate stream: either Captu...">NTV2Mode</a> enumeration in the SDK.<ul>
<li>In <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5abec59926c3de1fac4acd02f438a2a634" title="Playout (output) mode, which reads from device SDRAM.">NTV2_MODE_DISPLAY</a> mode, video data is <b>read</b> from SDRAM for playout.<ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a2a59728d0474fc70c9887b81eecad127">NTV2DeviceCanDoPlayback</a> to determine if the device is capable of playing video from SDRAM.</li>
</ul>
</li>
<li>In <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46" title="Capture (input) mode, which writes into device SDRAM.">NTV2_MODE_CAPTURE</a> mode, video data is <b>written</b> into SDRAM.<ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ab5189daf688987b280922fb6cde1466f">NTV2DeviceCanDoCapture</a> to determine if the device is capable of recording video into SDRAM.</li>
</ul>
</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0f1f023340d0b4e2f31949ae9684b46d" title="Answers with the current NTV2Mode of the given FrameStore on the AJA device.">CNTV2Card::GetMode</a> to obtain the <b>FrameStore</b>’s current <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5" title="Used to identify the mode of a Frame Store, or the direction of an AutoCirculate stream: either Captu...">NTV2Mode</a>.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033" title="Determines if a given FrameStore on the AJA device will be used to capture or playout video.">CNTV2Card::SetMode</a> to set the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5" title="Used to identify the mode of a Frame Store, or the direction of an AutoCirculate stream: either Captu...">NTV2Mode</a>.</li>
<li>If <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> is used, the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5" title="Used to identify the mode of a Frame Store, or the direction of an AutoCirculate stream: either Captu...">NTV2Mode</a> is automatically set (but it’s not automatically “un-set” after use).</li>
</ul>
</li>
<li><b>Frame Buffer Format</b> — This determines the format of the pixel data being written or read to or from device SDRAM (when <b>Enabled</b>), and coincides with the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a80edd7ce906ff76d34d139d3b3dbf5f4" title="An alias for NTV2FrameBufferFormat.">NTV2PixelFormat</a> (aka <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ace03c7b6e4f21738519430d1fa42161c" title="Identifies a particular video frame buffer format. See Device Frame Buffer Formats for details.">NTV2FrameBufferFormat</a>) enumeration in the SDK. (See <a class="el" href="../../d5/d32/dataformats.html#devicefbformats">Device Frame Buffer Formats</a> for a description of the various formats.)<ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a9d07eb5c9d052b573df4a4745cb9d2fa">NTV2DeviceCanDoFrameBufferFormat</a> to determine if a specific <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a80edd7ce906ff76d34d139d3b3dbf5f4" title="An alias for NTV2FrameBufferFormat.">NTV2PixelFormat</a> is supported by the device.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a197831a736299e2c68e3f7f0f860387f" title="Returns the current frame buffer format for the given FrameStore on the AJA device.">CNTV2Card::GetFrameBufferFormat</a> to determine the current <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a80edd7ce906ff76d34d139d3b3dbf5f4" title="An alias for NTV2FrameBufferFormat.">NTV2PixelFormat</a> setting.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a35aeceda35a4730ed9e7de0d7d620363" title="Sets the frame buffer format for the given FrameStore on the AJA device.">CNTV2Card::SetFrameBufferFormat</a> to change the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a80edd7ce906ff76d34d139d3b3dbf5f4" title="An alias for NTV2FrameBufferFormat.">NTV2PixelFormat</a> setting.</li>
<li><a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> users should configure this before calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ae617507f1b0562f866201a58c26e10e7" title="Starts AutoCirculating the specified channel that was previously initialized by CNTV2Card::AutoCircul...">CNTV2Card::AutoCirculateStart</a>.</li>
</ul>
</li>
<li><b>Video Format</b> — This determines the format of the video being received by, or transmitted to, the <b>FrameStore</b>. This correlates to the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686" title="Identifies a particular video format.">NTV2VideoFormat</a> enumeration in the SDK, which implies a <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54af" title="Identifies a particular video frame geometry.">NTV2FrameGeometry</a>, <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a43dc13753bbda370daa22fa9be5e0f14" title="Identifies a particular video standard.">NTV2Standard</a> and <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ad5d23b1875f7b840e92723d7841995fd" title="Identifies a particular video frame rate.">NTV2FrameRate</a>.<ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#afe6e547f41728c0974b20f2281d83527">NTV2DeviceCanDoVideoFormat</a> to determine if a specific <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686" title="Identifies a particular video format.">NTV2VideoFormat</a> is supported by the device.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aa2fd595db82ca28dcedcdb77c3ac99ab">CNTV2Card::GetVideoFormat</a> to determine the current <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686" title="Identifies a particular video format.">NTV2VideoFormat</a> setting.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#adb92dcd7e53f763de2fa82b519082bec" title="Configures the AJA device to handle a specific video format.">CNTV2Card::SetVideoFormat</a> to change the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686" title="Identifies a particular video format.">NTV2VideoFormat</a> setting.</li>
<li><a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> users should configure this before calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ae617507f1b0562f866201a58c26e10e7" title="Starts AutoCirculating the specified channel that was previously initialized by CNTV2Card::AutoCircul...">CNTV2Card::AutoCirculateStart</a>.</li>
</ul>
</li>
<li><b>Input Frame</b> — A register whose unsigned integer value designates the specific Frame Buffer in SDRAM that will be written with video frame data (assuming the <b>FrameStore</b> is <b>Enabled</b> and its <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5" title="Used to identify the mode of a Frame Store, or the direction of an AutoCirculate stream: either Captu...">NTV2Mode</a> is <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46" title="Capture (input) mode, which writes into device SDRAM.">NTV2_MODE_CAPTURE</a>, and a valid signal is being received at the <b>FrameStore</b>’s input crosspoint). See <a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fbindexing">Frame Buffer Indexing</a> for more information.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac26d1a0814509ddda2d050dc4e0abc73" title="Answers with the current input frame index number for the given FrameStore. This identifies which par...">CNTV2Card::GetInputFrame</a> to determine the current <b>Input Frame</b> buffer number.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11" title="Sets the input frame index number for the given FrameStore. This identifies which frame in device SDR...">CNTV2Card::SetInputFrame</a> to change it.</li>
<li><a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculatecapture">AutoCirculate Capture</a> users should ignore this value, as it’s managed automatically.</li>
<li>Setting this register while the FrameStore is recording video mid-frame into SDRAM will not interrupt the current in-progress frame, but instead will take effect at the next field or frame VBI, depending on the FrameStore’s <b>Register Write Mode</b> (see below).</li>
</ul>
</li>
<li><b>Output Frame</b> — A register whose unsigned integer value designates the specific Frame Buffer in SDRAM that will be read (assuming the <b>FrameStore</b> is <b>Enabled</b> and its <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5" title="Used to identify the mode of a Frame Store, or the direction of an AutoCirculate stream: either Captu...">NTV2Mode</a> is <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5abec59926c3de1fac4acd02f438a2a634" title="Playout (output) mode, which reads from device SDRAM.">NTV2_MODE_DISPLAY</a>). See <a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fbindexing">Frame Buffer Indexing</a> for more information.<ul>
<li>The output video can be monitored <b>if</b> the <b>FrameStore</b>’s output signal is routed to a video output widget, and a monitor is connected to its output connector.)</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3156fe29ba66d5ad8df58750fba59978" title="Answers with the current output frame number for the given FrameStore (expressed as an NTV2Channel).">CNTV2Card::GetOutputFrame</a> to determine the current <b>Output Frame</b> buffer number.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1f528a34e2c5a5b481b846434396a784" title="Sets the output frame index number for the given FrameStore. This identifies which frame in device SD...">CNTV2Card::SetOutputFrame</a> to change it.</li>
<li><a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculatecapture">AutoCirculate Capture</a> users should ignore this value, as it’s managed automatically.</li>
<li>Setting this register while the FrameStore is transmitting video mid-frame will not interrupt the current in-progress frame, but instead will take effect at the next field or frame VBI, depending on the FrameStore’s <b>Register Write Mode</b> (see below).</li>
</ul>
</li>
<li><b>VANC Mode</b> — The <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abcba86c92aeadc025b854b7157baddc7" title="These enum values identify the available VANC modes.">NTV2VANCMode</a> setting determines if a “tall” or “taller” frame geometry is in effect. The <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abcba86c92aeadc025b854b7157baddc7aed934f6f5213f1b095f053619f328bb3" title="This identifies the &quot;tall&quot; mode in which there are some VANC lines in the frame buffer.">NTV2_VANCMODE_TALL</a> geometry incorporates several extra lines of video that precede the first visible line in the raster into the <b>FrameStore</b>’s frame buffer memory. <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abcba86c92aeadc025b854b7157baddc7a19000e5c813d8fefed568ccacda79b0a" title="This identifies the mode in which there are some + extra VANC lines in the frame buffer.">NTV2_VANCMODE_TALLER</a> was added to firmware when it was found that additional useful ancillary data was found on additional lines ahead of the first line in <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abcba86c92aeadc025b854b7157baddc7aed934f6f5213f1b095f053619f328bb3" title="This identifies the &quot;tall&quot; mode in which there are some VANC lines in the frame buffer.">NTV2_VANCMODE_TALL</a> mode.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aeb150e72f3c506d2510a8500eab2c119" title="Retrieves the current VANC mode for the given FrameStore.">CNTV2Card::GetVANCMode</a> to determine the current <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abcba86c92aeadc025b854b7157baddc7" title="These enum values identify the available VANC modes.">NTV2VANCMode</a> setting.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#abbb0a91d16cddb3fc10a5d867f92e582" title="Sets the VANC mode for the given FrameStore.">CNTV2Card::SetVANCMode</a> to change it.</li>
</ul>
</li>
<li><b>VANC Data Shift Mode</b> — The <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a52ef2da10fd05237b9da320e75888ae8">NTV2VANCDataShiftMode</a> determines if the firmware will automatically right-shift incoming (or left-shift outgoing) data words by 2 bits in the VANC lines in <a class="el" href="../../d5/d32/dataformats.html#fbformat8bitycbcr">8-Bit YCbCr Format</a> frame buffers, making it easy to read (or write) ancillary data packets in the frame buffer.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a6d8c6925dda7aa8e9b0cb903e8b25d78" title="Retrieves the current &quot;VANC Shift Mode&quot; feature for the given channel.">CNTV2Card::GetVANCShiftMode</a> to determine the current <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a52ef2da10fd05237b9da320e75888ae8">NTV2VANCDataShiftMode</a> setting.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7599cff630fc737368608cd795be2949" title="Enables or disables the &quot;VANC Shift Mode&quot; feature for the given channel.">CNTV2Card::SetVANCShiftMode</a> to change it.</li>
</ul>
</li>
<li><b>Frame Buffer Orientation</b> — The <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abae0f092f4f517b23c051599c3c42e09">NTV2FBOrientation</a> (a.k.a. <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a3d16b7de47a5d15904f934875b27f2f1">NTV2FrameBufferOrientation</a> a.k.a. <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac03b1be56c369c6a72769a56770049f5" title="Determines the order that raster lines are written into, or read out of, frame buffer memory on the d...">NTV2VideoFrameBufferOrientation</a>) determines the direction that firmware will write or read video lines into or out of SDRAM, either normal <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac03b1be56c369c6a72769a56770049f5a0a0c72f7d643a4b3f990548053dcb054">NTV2_FRAMEBUFFER_ORIENTATION_TOPDOWN</a>, or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac03b1be56c369c6a72769a56770049f5a993922c743f83e47053886317b17623c">NTV2_FRAMEBUFFER_ORIENTATION_BOTTOMUP</a> (reverse, which flips the image vertically).<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a32f51d88e46dbb799f18fa1e5a774ad4" title="Answers with the current frame buffer orientation for the given NTV2Channel.">CNTV2Card::GetFrameBufferOrientation</a> to determine the current setting.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af912415005661c169157725ab77767bc" title="Sets the frame buffer orientation for the given NTV2Channel.">CNTV2Card::SetFrameBufferOrientation</a> to change it.</li>
</ul>
</li>
<li><b>Register Write Mode</b> — The <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a86467246392bf24da8f2222e86cacccc" title="These values are used to determine when certain register writes actually take effect....">NTV2RegisterWriteMode</a> determines when a change made to the FrameStore’s <b>Input Frame</b> or <b>Output Frame</b> registers will actually take effect.<ul>
<li>The mode is either <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a86467246392bf24da8f2222e86cacccca970896cf61b24c18da30b0068a93da79" title="Field Mode: Register changes take effect at the next field VBI.">NTV2_REGWRITE_SYNCTOFIELD</a> or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a86467246392bf24da8f2222e86cacccca9aa5347d568de1dda8a8627bc44c8450" title="Frame Mode: Register changes take effect at the next frame VBI (power-up default).">NTV2_REGWRITE_SYNCTOFRAME</a>.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#afaed9109562df4cd084767ba9336db52" title="Answers with the FrameStore&#39;s current NTV2RegisterWriteMode setting, which determines when CNTV2Card:...">CNTV2Card::GetRegisterWriteMode</a> to determine the current setting.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af54353571aa062706f35b55f96103078" title="Sets the FrameStore&#39;s NTV2RegisterWriteMode, which determines when CNTV2Card::SetInputFrame or CNTV2C...">CNTV2Card::SetRegisterWriteMode</a> to change it.</li>
<li>See <a class="el" href="../../d1/dc5/ntv2devops.html#fieldframeinterrupts">Field/Frame Interrupts</a> for more details.</li>
</ul>
</li>
</ul>
<p>In the SDK, FrameStores are identified by an <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dce" title="These enum values are mostly used to identify a specific Frame Store. They&#39;re also commonly used to i...">NTV2Channel</a> enumeration and sometimes by a zero-based unsigned integer value, where zero corresponds to <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6" title="Specifies channel or Frame Store 1 (or the first item).">NTV2_CHANNEL1</a>.</p><ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a24ca0752d39b65e318fdf16285067c30">NTV2DeviceGetNumFrameStores</a> to determine the number of FrameStores on a given device. This will tell you how many Channels are available for simultaneous Capture and/or Output streams.</li>
<li>Devices having only one <b>FrameStore</b> are limited to Capturing or Playing a single stream of video at a time.</li>
<li>Devices with more than one <b>FrameStore</b> can independently input or output more than one video stream simultaneously, with each <b>FrameStore</b> accessing SDRAM.</li>
<li>A few older AJA devices (e.g. <a class="el" href="../../d0/d53/ntv2devices.html#corvid1corvid3g">Corvid, Corvid 3G</a>) had two <b>FrameStore</b>s, but <b>FrameStore 1</b> was dedicated to <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46" title="Capture (input) mode, which writes into device SDRAM.">NTV2_MODE_CAPTURE</a>, and <b>FrameStore 2</b> to <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5abec59926c3de1fac4acd02f438a2a634" title="Playout (output) mode, which reads from device SDRAM.">NTV2_MODE_DISPLAY</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In NTV2 parlance, the terms <b>Channel</b> and <b>FrameStore</b> are often used interchangeably.</dd></dl>
<h2><a class="anchor" id="independentmode"></a>
Multi-Format / “Independent” Mode</h2>
<p><b>Multi-Format Mode</b>, also known as “Independent” mode, is a device capability in which it can simultaneously operate more than one stream, with each having a different video format. Devices having this capability that are in this mode are able to use a different <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686" title="Identifies a particular video format.">NTV2VideoFormat</a> on each <b>FrameStore</b>.</p>
<p>This differs from prior device capability. For example, assuming there was sufficient DMA and processor bandwidth on the host, the <a class="el" href="../../d0/d53/ntv2devices.html#corvid24">Corvid 24</a> could simultaneously ingest two video streams, and playout another two video streams — but all four streams must have the identical <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8f85ca8efb8928620e1fbb6282a5e686" title="Identifies a particular video format.">NTV2VideoFormat</a>.</p>
<p>In <b>Multi-Format Mode</b>, for example, assuming sufficient PCIe and host processor bandwidth, the <a class="el" href="../../d0/d53/ntv2devices.html#corvid44">Corvid 44</a> could simultaneously ingest <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aed10f029a5332ade780fff81b5db8bdfa8570f1c84cdf3cbbfe0ecedb967f3842">NTV2_FORMAT_720p_5000</a> and <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aed10f029a5332ade780fff81b5db8bdfa603f669a6e8a7dcd5d384fd2bceb6d69">NTV2_FORMAT_525_5994</a> while playing <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aed10f029a5332ade780fff81b5db8bdfa7d4a6db61d83a5d809b08ca22d88b564">NTV2_FORMAT_1080p_2997</a> and <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aed10f029a5332ade780fff81b5db8bdfa0858edf6feb0ae3e44e03ef372e42d37">NTV2_FORMAT_720p_5994</a>.</p>
<p>The relevant SDK calls:</p><ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#aef5852308d0853201208edf44bad20ea">NTV2DeviceCanDoMultiFormat</a> to determine if a device is capable of simultaneously streaming multiple, different video formats.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3a725a1899c9b85e93d03176e281c349" title="Answers if the device is operating in multiple-format per channel (independent channel) mode or not....">CNTV2Card::GetMultiFormatMode</a> to find out if the device is currently operating in Multi-Format Mode or not.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a4e63d1baaef7173535588fbd434f9845" title="Enables or disables multi-format (per channel) device operation. If enabled, each device channel can ...">CNTV2Card::SetMultiFormatMode</a> to change the mode.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This “Independent Mode” doesn’t mean that the FrameStores cannot interfere with each other’s frame buffer memory. FrameStores have equal access to any frame buffer in device SDRAM. Therefore, if you use frame buffers 0…5 for Channel 1, you must take care to <em>not</em> use frames 0…5 for any other channel on the device (unless you have good reason to do so). See <a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fbconflict">When FrameStores Access the Same Frame Buffer Memory</a> (below) for more information.</dd>
<dd>
In <b>Multi-Format Mode</b>, because NTV2 devices only have one hardware clock for driving the outputs, all <em>output</em> video formats must be in the same <b>Clock Family</b>. Call <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#a2679e8c4734354afa8dc3ca1089cfc8f" title="Compares two video formats and returns true if they are &quot;compatible&quot; (with respect to a multiformat-c...">IsMultiFormatCompatible(const NTV2VideoFormat, const NTV2VideoFormat)</a> to find out if two video formats are multi-format compatible. Call <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#aa03bd6c294c539b1cfe3aa56518393fa" title="Compares two frame rates and returns true if they are &quot;compatible&quot; (with respect to a multiformat-cap...">IsMultiFormatCompatible(const NTV2FrameRate, const NTV2FrameRate)</a> to see if two frame rates are multi-format compatible. Call <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#ab22092ada10fd5fb607b13655f1bd8f1">GetFrameRateFamily</a> to determine the <b>Clock Family</b> that a given <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ad5d23b1875f7b840e92723d7841995fd" title="Identifies a particular video frame rate.">NTV2FrameRate</a> belongs to. See <a class="el" href="../../d1/dc5/ntv2devops.html#deviceclockingandsync">Device Clocking and Synchronization</a> for more details (below).</dd></dl>
<h2><a class="anchor" id="vidop-fbaccess"></a>
Frame Buffer Access</h2>
<p>Data can be transferred to or from the device at any time using the DMA API in the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html" title="I interrogate and control an AJA video/audio capture/playout device.">CNTV2Card</a> class, or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a> if using <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a>.</p>
<p>Since the host computer <b>always has unrestricted access to frame memory at any time</b>, it’s critical to synchronize or gate transfers to/from the host using the vertical blanking interrupt (e.g., <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0599dc483977c64978cae92fb8837252" title="Efficiently sleeps the calling thread/process until the next one or more field (interlaced video) or ...">CNTV2Card::WaitForOutputVerticalInterrupt</a>, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac05240d99252c18d39dbdba3086ca72e" title="Efficiently sleeps the calling thread/process until the next output VBI for the given field and outpu...">CNTV2Card::WaitForOutputFieldID</a>, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a56552aedb9631efa04e1ff8ea96be02b" title="Efficiently sleeps the calling thread/process until the next one or more field (interlaced video) or ...">CNTV2Card::WaitForInputVerticalInterrupt</a>, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1828395a3ecab209ad8a7a4ab5d9f5cf" title="Efficiently sleeps the calling thread/process until the next input VBI for the given field and input ...">CNTV2Card::WaitForInputFieldID</a>, etc.). The transfer functions don't wait — they immediately perform the transfer, and wonʼt return until they finish (or fail).</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a321815c3e8bed38b2370baa1fb1b5fd0" title="Transfers a single frame from the host to the AJA device.">CNTV2Card::DMAWriteFrame</a> at a fraction of frame time <em>after</em> the VBI to write the same frame on the device that’s being read for the currently-playing video frame will likely look torn or distorted. Likewise for the opposite — i.e., calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a431e77d0e1cb52855a80fbbeab954e04" title="Transfers a single frame from the AJA device to the host.">CNTV2Card::DMAReadFrame</a> at a fraction of frame time after or before the VBI to read the same frame being written by the <b>FrameStore</b> from the incoming video frame would result in some lines having pixel data from the new, incoming frame, while the remaining lines would contain old pixel data.</dd></dl>
<p>For extremely tight latency, <b>FrameStore 1</b> has a <a class="el" href="../../d4/dd7/ntv2publicinterface_8h.html#a44465b2926268ea111cf5d357016baefa75d915275aff5bb9f549d1282ef0439d">kRegLineCount</a> register that can be monitored (via <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2dcc91b1603a63b44c615fc40d92a351" title="Answers with the line offset into the frame currently being read (NTV2_MODE_DISPLAY) or written (NTV2...">CNTV2Card::ReadLineCount</a> ), so that small bands of raster lines can be transferred “ahead of” the line counter (for playback) or “behind” it (for capture). However, other FrameStores (2 or higher) do not have <b>Line Counter</b> registers.</p>
<p>There are several DMA API functions for transferring data between host memory and device SDRAM. They are <b>frame-centric</b> in that they all require a zero-based index number or <b>Frame Offset</b> to calculate where to start reading or writing in device SDRAM.</p>
<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a431e77d0e1cb52855a80fbbeab954e04" title="Transfers a single frame from the AJA device to the host.">CNTV2Card::DMAReadFrame</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a321815c3e8bed38b2370baa1fb1b5fd0" title="Transfers a single frame from the host to the AJA device.">CNTV2Card::DMAWriteFrame</a> to transfer frame data from or to device SDRAM (respectively).</li>
<li><b>Frame Number</b> — See <a class="el" href="../../d1/dc5/ntv2devops.html#vidop-fbindexing">Frame Buffer Indexing</a> (below) for details.</li>
<li><b>Byte Count:</b><ul>
<li>Should be even, or evenly divisible by 4, or ideally a power of two.</li>
<li>Small transfers can sometimes be problematic for certain DMA engine firmware in combination with certain host hardware and OS platforms. To avoid this, AJA recommends transferring at least 4096 bytes of data. Try smaller values if necessary, but test thoroughly with the devices and hardware you intend to support.</li>
<li>It can be larger than a frame. For example, if the device frame size is 8MB, and the requested byte count is 16MB, two frames will be transferred.</li>
</ul>
</li>
<li><a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#acaaf1e46f56cd4189e3c861249d4a564" title="Transfers data from the AJA device to the host.">CNTV2Card::DMARead</a> and <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a258fc2b04b0773f539f49a8ea7116947" title="Transfers data from the host to the AJA device.">CNTV2Card::DMAWrite</a> are similar, but also accept a <b>Byte Offset</b>, which…<ul>
<li>Should be even, or evenly divisible by 4, or ideally a power of two.</li>
<li><b>Hint:</b> All device SDRAM can be accessed by using a zero <b>Frame Number</b> and using any offset value needed (up to 4GB minus the <b>Byte Count</b>).</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>DMA transfer speeds may be affected by the amount of video data being accessed by the device to transmit video. If a channel is in display mode, it is always playing video, and therefore reading from SDRAM, consuming SDRAM bandwidth… the amount consumed determined by the amount of data being read from frame memory… which depends on <a class="el" href="../../d5/d32/dataformats.html#fbframegeometries">Frame Buffer Geometries</a> and <a class="el" href="../../d5/d32/dataformats.html#devicefbformats">Device Frame Buffer Formats</a>. <b>In some cases, DMA speeds can be increased by disabling unused channels</b> (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad7b7b304fea36b3323f1fb2c75fbf69b" title="Disables the given FrameStore.">CNTV2Card::DisableChannel</a>). Disabling unused channels is especially useful when using larger video and frame buffer formats, which use significant SDRAM bandwidth to read frame data for playout. In addition to the fact that more data is moved in, say, 48-bit RGB (than YUV8), the transfer of that data may also proceed at a slightly slower rate.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Accessing memory addresses that are beyond the end of device SDRAM is not recommended, and will result in unexpected behavior — e.g. wrapping around and continuing from the start of device SDRAM.</dd></dl>
<p><a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> users should call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a> to transfer video, audio, and/or ancillary data. By default, it knows the correct frame in device SDRAM to source (for capture) or target (for playback).</p>
<h3><a class="anchor" id="vidop-fbindexing"></a>
Frame Buffer Indexing</h3>
<p><b>FrameStore</b>s access frame data in SDRAM starting at <b>Frame Offset</b>s measured from the start of SDRAM (at address zero).</p><ul>
<li>The first byte of the first raster line of the first frame coincides with SDRAM address <code>0x00000000</code>.</li>
<li><b>Frame Offset</b>s are always multiples of the “intrinsic” frame size of the device, which defaults to <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a7da0d50931cd5e572cb6f926d18dfd8aadacf289f06afb00c0b8d4c3ff6ab1b6e">NTV2_FRAMESIZE_8MB</a> (8MB).</li>
<li>The intrinsic frame size applies globally to all FrameStores on the device.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2b2bd4f5a6b60b21e8b2ba87680eb27e" title="Answers with the frame size currently being used on the device.">CNTV2Card::GetFrameBufferSize</a> to discover the current intrinsic frame size.</li>
<li>When any FrameStoreʼs <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54af" title="Identifies a particular video frame geometry.">NTV2FrameGeometry</a> or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a80edd7ce906ff76d34d139d3b3dbf5f4" title="An alias for NTV2FrameBufferFormat.">NTV2PixelFormat</a> changes, the intrinsic frame size can change. Since Frame Offsets are always multiples of the deviceʼs intrinsic frame size, this means that the Frame Offsets for <em>all</em> FrameStores can change whenever <em>any</em> FrameStoreʼs <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54af" title="Identifies a particular video frame geometry.">NTV2FrameGeometry</a> or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a80edd7ce906ff76d34d139d3b3dbf5f4" title="An alias for NTV2FrameBufferFormat.">NTV2PixelFormat</a> changes.</li>
<li>The following table shows a sampling of actual raster sizes for three pixel formats: <a class="el" href="../../d5/d32/dataformats.html#fbformat10bitycbcr">10-Bit YCbCr Format</a>, <a class="el" href="../../d5/d32/dataformats.html#fbformats8bitrgb">8-Bit ARGB, RGBA, ABGR Formats</a>, and <a class="el" href="../../d5/d32/dataformats.html#fbformats48bitrgb">48-Bit RGB</a>.<br  />
 <table class="doxtable">
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54af" title="Identifies a particular video frame geometry.">NTV2FrameGeometry</a> </td><td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a43dc13753bbda370daa22fa9be5e0f14" title="Identifies a particular video standard.">NTV2Standard</a> </td><td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#abcba86c92aeadc025b854b7157baddc7" title="These enum values identify the available VANC modes.">NTV2VANCMode</a> </td><td><b>Raster</b> </td><td><b>10-bit YUV</b> </td><td><b>8-bit RGBA</b> </td><td><b>48-bit RGB</b> </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afa3053750cdf4c52c4de90b8474647f92a" title="720x486, for NTSC 525i and 525p60, NTV2_VANCMODE_OFF">NTV2_FG_720x486</a> </td><td>SD 525i </td><td>Off </td><td>720×486 </td><td>0.89 MB </td><td>1.33 MB </td><td>2.00 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afab65391cfb734636233c29b20e9f148cc" title="720x486, for NTSC 525i, NTV2_VANCMODE_TALL">NTV2_FG_720x508</a> </td><td>SD 525i </td><td>Tall </td><td>720×508 </td><td>0.93 MB </td><td>1.40 MB </td><td>2.09 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afac21a4ec056124f104fb32f8c4e95ef0e" title="720x486, for NTSC 525i and 525p60, NTV2_VANCMODE_TALLER">NTV2_FG_720x514</a> </td><td>SD 525i </td><td>Taller </td><td>720×514 </td><td>0.94 MB </td><td>1.41 MB </td><td>2.12 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afa3b955efd781950b81a91c0c12227b232" title="720x576, for PAL 625i, NTV2_VANCMODE_OFF">NTV2_FG_720x576</a> </td><td>SD 625i </td><td>Off </td><td>720×576 </td><td>1.05 MB </td><td>1.58 MB </td><td>2.37 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afaf266b9d7de8860d476ca2d6ee2904e6a" title="720x576, for PAL 625i, NTV2_VANCMODE_TALL">NTV2_FG_720x598</a> </td><td>SD 625i </td><td>Tall </td><td>720×598 </td><td>1.09 MB </td><td>1.64 MB </td><td>2.46 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afa62bfe2df9e9aef229d175be015cc6325" title="720x576, for PAL 625i, NTV2_VANCMODE_TALLER">NTV2_FG_720x612</a> </td><td>SD 625i </td><td>Tall </td><td>720×612 </td><td>1.12 MB </td><td>1.68 MB </td><td>2.52 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afa851b0cbbb6d0992fd6924b68bb9b9354" title="1280x720, for 720p, NTV2_VANCMODE_OFF">NTV2_FG_1280x720</a> </td><td>HD 720p </td><td>Off </td><td>1280×720 </td><td>2.37 MB </td><td>3.52 MB </td><td>5.27 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afad79a96e9f283a8fd77c859c7b14b2105" title="1280x720, for 720p, NTV2_VANCMODE_TALL">NTV2_FG_1280x740</a> </td><td>HD 720p </td><td>Tall </td><td>1280×740 </td><td>2.44 MB </td><td>3.61 MB </td><td>5.42 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afaf2edd0aa7af826d340b9e2c78745ddc0" title="1920x1080, for 1080i and 1080p, NTV2_VANCMODE_OFF">NTV2_FG_1920x1080</a> </td><td>HD 1080 </td><td>Off </td><td>1920×1080 </td><td>5.27 MB </td><td>7.91 MB </td><td>11.9 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afa4f96bfcfb1f4b49922b61d10c0e42d6d" title="1920x1080, for 1080i and 1080p, NTV2_VANCMODE_TALL">NTV2_FG_1920x1112</a> </td><td>HD 1080 </td><td>Taller </td><td>1920×1112 </td><td>5.43 MB </td><td>8.14 MB </td><td>12.2 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afaca277878397abf0a94966beaf121f503" title="1920x1080, NTV2_VANCMODE_TALLER">NTV2_FG_1920x1114</a> </td><td>HD 1080 </td><td>Tall </td><td>1920×1114 </td><td>5.44 MB </td><td>8.16 MB </td><td>12.2 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afa75d267a1c3696223110fa6361552b80d" title="2048x1080, for 2Kx1080p, NTV2_VANCMODE_OFF">NTV2_FG_2048x1080</a> </td><td>HD 2K×1080 </td><td>Off </td><td>2048×1080 </td><td>5.67 MB </td><td>8.44 MB </td><td>12.7 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afacd674cef2a5cfe254a0ee191331a49f1" title="2048x1080, for 2Kx1080p, NTV2_VANCMODE_TALL">NTV2_FG_2048x1112</a> </td><td>HD 2K×1080 </td><td>Tall </td><td>2048×1112 </td><td>5.84 MB </td><td>8.69 MB </td><td>13.0 MB </td></tr>
<tr>
<td><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54afae1dbf3ad1de99723d6438d0b67223235" title="2048x1080, NTV2_VANCMODE_TALLER">NTV2_FG_2048x1114</a> </td><td>HD 2K×1080 </td><td>Taller </td><td>2048×1114 </td><td>5.85 MB </td><td>8.70 MB </td><td>13.1 MB </td></tr>
</table>
</li>
<li>After a geometry and/or pixel format change, when the required raster size of <em>any</em> FrameStore exceeds 8MB, the firmware automatically increases the intrinsic frame size to 16MB.<ul>
<li>After switching to 16MB, note that the frame buffer capacity of the device is cut in half. For example, if a device could store 100 × 8MB frames, after the bump to 16MB, it will only hold 50 frames.<ul>
<li><b>WARNING:</b> This can adversely affect <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> streaming. For example, if frame buffers 45 thru 55 were used for <a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculatecapture">AutoCirculate Capture</a> using 8MB offsets, after the switch to 16MB, frames 50 thru 55 would be invalid, and “out of bounds”, resulting in undefined behavior.</li>
</ul>
</li>
</ul>
</li>
<li>Conversely, when no FrameStores require 16MB frame sizes, the firmware automatically reverts the intrinsic frame size to 8MB. (However, on some devices, this behavior can be changed. See below.)</li>
<li>Most devices automatically switch to the larger 16MB size whenever <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abcba86c92aeadc025b854b7157baddc7" title="These enum values identify the available VANC modes.">NTV2VANCMode</a> is enabled (i.e. “tall” or “taller”) on any FrameStore.</li>
<li><b>WARNING:</b> On devices with more than one FrameStore, if any other FrameStores are streaming video in their respective frame buffer ranges when the instrinsic frame size changed, there will be a noticeable glitch in their captured or outgoing video streams.<ul>
<li>Most devices can be pre-set and locked to 16MB to avoid Frame Size switching (and prevent video glitching).</li>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a58c20e65fe21cc1ec035d77b0a4e9732">NTV2DeviceSoftwareCanChangeFrameBufferSize</a> to determine if the device supports this 16MB pre-set/lock feature.</li>
<li>Call <code>CNTV2Card::SetFrameBufferSize(NTV2_CHANNEL1, ::NTV2_FRAMESIZE_16MB);</code> to set the larger size in advance.</li>
</ul>
</li>
<li><b>UHD/4K and UHD2/8K Frame Offsets</b><ul>
<li><b>UHD/4K</b> — Frame Offsets are 4 times the 8MB/16MB intrinsic frame size. This means that, from the FrameStoreʼs point of view, the deviceʼs frame capacity drops by ¼ when configured for UHD/4K video.</li>
<li><b>UHD2/8K</b> — Frame Offsets are 16 times the 8MB/16MB intrinsic frame size. This means that, from the FrameStoreʼs point of view, the deviceʼs frame capacity drops by a factor of 16 when configured for UHD2/8K video.</li>
</ul>
</li>
<li><b>Frame Range Considerations When Streaming Both SD/HD and UHD/4K/8K</b><ul>
<li>It can be tricky to determine frame ranges for SD/HD, UHD/4K, and/or UHD2/8K streams that won't interfere with each other.</li>
<li>UHD/4K frame offsets are 4 times larger than the intrinsic SD/HD offsets.</li>
<li>UHD2/8K frame offsets are 16 times larger than the intrinsic SD/HD offsets.</li>
<li><b>Example:</b> A device with SDRAM for up to 120 × 8MB frames must operate three streams, each with a 10-frame latency:<ul>
<li><b>Channel 1:</b> continuous playout of UHDp60 from 8-bit ARGB;</li>
<li><b>Channel 2:</b> Capture various, intermittent video signals up to 1080p as 48-bit RGBA; the signals come and go;</li>
<li><b>Channel 3:</b> Non-stop capture of continuous 525i SD signal as 10-bit YCbCr;</li>
<li><b>Solution:</b><ul>
<li>The intrinsic frame size of 8MB is too small to accommodate 1080p rasters at 48-bit RGB (11.9MB). Therefore, to avoid glitches, the device will be pre-set to 16MB before starting any streams. The deviceʼs frame capacity is now only 60 × 16MB frames.</li>
<li>On <b>Channel 1</b>, <a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculateplayout">AutoCirculate Playout</a> UHD frames 0 thru 9. Because each UHD frame uses 4 intrinsic frames, the first available 16MB frame after this channelʼs buffers is frame 40.</li>
<li>On <b>Channel 2</b>, when a valid signal is received, <a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculatecapture">AutoCirculate Capture</a> frames 40 thru 49.</li>
<li>On <b>Channel 3</b>, <a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculatecapture">AutoCirculate Capture</a> frames 50 thru 59.</li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> has a <a class="el" href="../../db/d02/toolsandutilities.html#memmapdlog">“Memory Map” Tool</a> that helps visualize device memory utilization.<br  />
 <div class="image">
<img src="../../watcher-tool-memmap.png" alt=""/>
</div>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="vidop-fblocking"></a>
Host Buffer Locking</h3>
<p>A DMA transfer using <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a>, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a431e77d0e1cb52855a80fbbeab954e04" title="Transfers a single frame from the AJA device to the host.">CNTV2Card::DMAReadFrame</a>, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a321815c3e8bed38b2370baa1fb1b5fd0" title="Transfers a single frame from the host to the AJA device.">CNTV2Card::DMAWriteFrame</a>, etc. requires the NTV2 device driver to perform these operations (ignoring some OS-dependent variations):</p><ol type="1">
<li>map the host buffer into kernel memory address space;</li>
<li>map and lock those pages into physical memory, where they must remain for the duration of the transfer;</li>
<li>build the segment list (or scatter-gather list) of memory segments for the DMA transfer (which also must remain in physical memory for the duration of the transfer);</li>
<li>perform the DMA transfer;</li>
<li>unmap/unlock all pages from physical (and kernel) memory.</li>
</ol>
<p>The mapping, locking and segment list construction steps can consume a substantial portion of the <a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirctimebudget">Per-Frame “Time Budget”</a>, especially with larger rasters and/or pixel formats, which can contribute to frame-drops.</p>
<p>In most use cases, client applications re-use the same host buffers over and over again. A substantial time savings can be realized if those host buffers are pre-locked and wired down into physical memory before entering the frame-processing loop (where <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a431e77d0e1cb52855a80fbbeab954e04" title="Transfers a single frame from the AJA device to the host.">CNTV2Card::DMAReadFrame</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a321815c3e8bed38b2370baa1fb1b5fd0" title="Transfers a single frame from the host to the AJA device.">CNTV2Card::DMAWriteFrame</a> are called).</p>
<p>Starting in SDK 16.0, new DMA API functions were added for this purpose:</p><ul>
<li><a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2f3c09f9f9f1ad5d0f92289a1baf8141" title="Page-locks the given host buffer to reduce transfer time and CPU usage of DMA transfers.">CNTV2Card::DMABufferLock</a> — maps and locks down a host buffer into physical memory.<ul>
<li>Starting with SDK 16.0.1, an optional parameter was added to also have the driver pre-build and cache the segment map (SGL) from the pre-locked buffer.</li>
</ul>
</li>
<li><a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a955ab57f0ac21cad21bc085ea66c76a7" title="Unlocks the given host buffer that was previously locked using CNTV2Card::DMABufferLock.">CNTV2Card::DMABufferUnlock</a> — unlocks and unmaps a host buffer that was previously locked.<ul>
<li>Starting in SDK 16.0.1, this also frees any previously cached segment map (SGL).</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="deviceclockingandsync"></a>
Device Clocking and Synchronization</h2>
<ul>
<li>NTV2 devices have <em>one</em> output clock that drives <em>all</em> SDI outputs.</li>
<li>When SDI output(s) are routed and connected, then device/output synchronization <em>must</em> be considered.</li>
</ul>
<h3><a class="anchor" id="devclock-capture"></a>
“Capture-Only”</h3>
<p>In <b>Capture</b> mode, the device firmware will calculate each input signal’s timing independently. If these signals are routed to FrameStores that are operating in <b>Capture</b> mode, the FrameStores will each signal VBIs independently at the correct time. For example: </p><div class="image">
<img src="../../hwref-inputtiming.png" alt=""/>
</div>
<ul>
<li>Repeated calls to <code>CNTV2Card::WaitForInputVerticalInterrupt(NTV2_CHANNEL2)</code> will occur at 50Hz;</li>
<li>Repeated calls to <code>CNTV2Card::WaitForInputVerticalInterrupt(NTV2_CHANNEL3)</code> will occur at 24Hz.</li>
</ul>
<p>On older devices with more than one FrameStore and “uniformat” firmware (deprecated starting in SDK 17.0), the input signals can still be captured independently, but they must be in the same frame rate “family” (i.e. <b>Clock Family</b>) as the overall device video format:<br  />
 <b>Related Clock Families:</b></p><ul>
<li>24 / 48</li>
<li>25 / 50 (PAL)</li>
<li>29.97 / 59.94 (NTSC)</li>
<li>30 / 60 / 120</li>
</ul>
<p>Devices with one FrameStore are essentially “uniformat” by nature.</p>
<h3><a class="anchor" id="devclock-inout"></a>
“Capture &amp; Playout”</h3>
<p>Add a route from FrameStore4 to SDIOut4, configuring the <b>FrameStore</b> for 1080i2997 playout: </p><div class="image">
<img src="../../hwref-inputoutputsync.png" alt=""/>
</div>
<p> In this scenario, there are now three output synchronization options:</p><ol type="1">
<li>Clock the output signal independently of the inputs and any other reference using the device’s internal clock. In this case, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af7ba7fb1976e09942caeb89219a396f8" title="Sets the device&#39;s clock reference source. See Device Clocking and Synchronization for more informatio...">CNTV2Card::SetReference</a> with <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa39fda6163a28fca5d7695e16f1dc9ecb" title="Specifies the device&#39;s internal clock.">NTV2_REFERENCE_FREERUN</a>.</li>
<li>Sync the outputs to a 29.97Hz (or 59.94Hz) external reference. For this case, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af7ba7fb1976e09942caeb89219a396f8" title="Sets the device&#39;s clock reference source. See Device Clocking and Synchronization for more informatio...">CNTV2Card::SetReference</a> with <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa4db1abd8ad50cb10940b888cbce434a7" title="Specifies the External Reference connector.">NTV2_REFERENCE_EXTERNAL</a>.</li>
<li>Sync the outputs to one of the SDI inputs. But note that this option is not viable in this example, because none of the input signals have 2997 or 5994 timing.</li>
</ol>
<p>If multiple input signals from the same <b>Clock Family</b> are feeding the device, it’s probably impossible to lock to them all, unless they’re all sync’d to a common timebase (often called “house reference”) … otherwise, the signals will all drift over time with respect to each other. For example, one signal may just be starting a new frame, while another is already half-way through its frame. Since the device clock can’t lock to more than one of them, <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa39fda6163a28fca5d7695e16f1dc9ecb" title="Specifies the device&#39;s internal clock.">NTV2_REFERENCE_FREERUN</a> must be used, to clock the outputs from the device’s own internal clock source. Note that setting “free run” isn’t technically necessary — the application would run just as well locked to one of the input signals, with the only difference being when the output signals would actually come out of the BNCs.</p>
<h3><a class="anchor" id="devclock-ee"></a>
“End-to-End” (“E-E”)</h3>
<p>Add a route from SDIIn2 to SDIOut4 (assume this route is actually implemented in the firmware): </p><div class="image">
<img src="../../hwref-ee-sync.png" alt=""/>
</div>
<p> This can be done either directly, as shown, or indirectly (for example, through a Mixer/Keyer widget). This requires the device’s output timing to be locked to the input signal. In this case, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af7ba7fb1976e09942caeb89219a396f8" title="Sets the device&#39;s clock reference source. See Device Clocking and Synchronization for more informatio...">CNTV2Card::SetReference</a> with <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfae6fa841fa5f858c702471cb09a1b4595" title="Specifies the SDI In 2 connector.">NTV2_REFERENCE_INPUT2</a>.</p>
<p>When the reference source is set to an SDI input, the output signal(s) will be locked to the same timebase as that of the designated source’s signal. For this to work, the output video format must have a frame rate in the same <b>Clock Family</b> as that being received at the SDI input. The actual output signal will exit the BNCs with about 2~3 lines of delay due to signal propagation through device circuitry, but the important point is that the phase relationship between the reference input signal and the output signal will be fixed, and will not drift.</p>
<dl class="section note"><dt>Note</dt><dd>For historical reasons, if SDI Input 1 is used for input and a signal is present, its signal frame rate dictates the <b>Clock Family</b> for all SDI outputs. When operating the device in multiformat mode, it’s therefore best to always use NTV2_CHANNEL1 as an output/playout channel, and use the other channels for input, as they don’t have the <b>Clock Family</b> restriction or any effect on the outputs.</dd></dl>
<h3><a class="anchor" id="devclock-extern"></a>
External Reference</h3>
<p>If the device’s output(s) must have a given timing (e.g., to feed a switcher), then applications can pass <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa4db1abd8ad50cb10940b888cbce434a7" title="Specifies the External Reference connector.">NTV2_REFERENCE_EXTERNAL</a> to <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af7ba7fb1976e09942caeb89219a396f8" title="Sets the device&#39;s clock reference source. See Device Clocking and Synchronization for more informatio...">CNTV2Card::SetReference</a>, which will lock the device to an analog or tri-level sync signal connected to the device’s external reference input.</p>
<p>To determine the video format of the signal being applied to the reference input, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac0619fcb6c6455c5ba69b5b49784a4fc" title="Returns the video format of the signal that is present on the device&#39;s reference input.">CNTV2Card::GetReferenceVideoFormat</a>.</p>
<dl class="section note"><dt>Note</dt><dd>When configured for <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa4db1abd8ad50cb10940b888cbce434a7" title="Specifies the External Reference connector.">NTV2_REFERENCE_EXTERNAL</a>, the device output will internally revert to Free-Run if the reference signal disappears or is incompatible with the output video format. When there’s no signal detected at the external reference connector, AJA recommends setting the device reference to <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa39fda6163a28fca5d7695e16f1dc9ecb" title="Specifies the device&#39;s internal clock.">NTV2_REFERENCE_FREERUN</a>.</dd></dl>
<h2><a class="anchor" id="fieldframeinterrupts"></a>
Field/Frame Interrupts</h2>
<p>Many device hardware registers are updated on the video frame sync (i.e. the VBI associated with the start of a new frame). This is determined by the <b>FrameStore</b>’s <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a86467246392bf24da8f2222e86cacccc" title="These values are used to determine when certain register writes actually take effect....">NTV2RegisterWriteMode</a> and is normally set to <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a86467246392bf24da8f2222e86cacccca9aa5347d568de1dda8a8627bc44c8450" title="Frame Mode: Register changes take effect at the next frame VBI (power-up default).">NTV2_REGWRITE_SYNCTOFRAME</a>.</p>
<p>For example, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11" title="Sets the input frame index number for the given FrameStore. This identifies which frame in device SDR...">CNTV2Card::SetInputFrame</a> is called by the client application to instruct the device’s <b>FrameStore</b> to write the next video frame that arrives into a specific frame buffer number in device memory. The function call immediately changes the <b>FrameStore</b>’s <b>Input Frame</b> register, but internally, the device firmware ensures that the <b>FrameStore</b> uses the new frame number value at the next <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235daa8ad180541cbe234428f84b9f918cccc" title="Identifies the first field in time for an interlaced video frame, or the first and only field in a pr...">NTV2_FIELD0</a> (first field in time) sync pulse. (To avoid a race condition, though, the client application must wait for the VBI, which gives it an entire frame time to update hardware registers and configure the device widget settings that are required for the next frame to be processed.)</p>
<p>For interlaced video, where the frame is transmitted as two fields, each field contains every other line of the frame. For HD video, the first field in time contains the first active line of the frame (i.e. the “top field” <em>a.k.a.</em> <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235daa8ad180541cbe234428f84b9f918cccc" title="Identifies the first field in time for an interlaced video frame, or the first and only field in a pr...">NTV2_FIELD0</a> <em>a.k.a.</em> <b>F1</b>); the second field contains the last active line of the frame (i.e. the “bottom field” <em>a.k.a.</em> <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235da407d6fb942e76b3afe49dea5b2bfb88b" title="Identifies the last (second) field in time for an interlaced video frame.">NTV2_FIELD1</a> <em>a.k.a.</em> <b>F2</b>). Each field starts with a video sync — however, normally, in <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a86467246392bf24da8f2222e86cacccca9aa5347d568de1dda8a8627bc44c8450" title="Frame Mode: Register changes take effect at the next frame VBI (power-up default).">NTV2_REGWRITE_SYNCTOFRAME</a> mode, the hardware registers are only updated at the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235daa8ad180541cbe234428f84b9f918cccc" title="Identifies the first field in time for an interlaced video frame, or the first and only field in a pr...">NTV2_FIELD0</a> sync. Each of the syncs (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235daa8ad180541cbe234428f84b9f918cccc" title="Identifies the first field in time for an interlaced video frame, or the first and only field in a pr...">NTV2_FIELD0</a> and <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235da407d6fb942e76b3afe49dea5b2bfb88b" title="Identifies the last (second) field in time for an interlaced video frame.">NTV2_FIELD1</a> ) signals an interrupt to the driver, but <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1828395a3ecab209ad8a7a4ab5d9f5cf" title="Efficiently sleeps the calling thread/process until the next input VBI for the given field and input ...">CNTV2Card::WaitForInputFieldID</a> (or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac05240d99252c18d39dbdba3086ca72e" title="Efficiently sleeps the calling thread/process until the next output VBI for the given field and outpu...">CNTV2Card::WaitForOutputFieldID</a>) check a hardware register and return only when the requested <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235d" title="These values are used to identify fields for interlaced video. See Field/Frame Interrupts and CNTV2Ca...">NTV2FieldID</a> is detected.</p>
<p>The <b>FrameStore</b> can alternatively be configured for <b>Field Mode</b> by passing <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a86467246392bf24da8f2222e86cacccca970896cf61b24c18da30b0068a93da79" title="Field Mode: Register changes take effect at the next field VBI.">NTV2_REGWRITE_SYNCTOFIELD</a> into <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af54353571aa062706f35b55f96103078" title="Sets the FrameStore&#39;s NTV2RegisterWriteMode, which determines when CNTV2Card::SetInputFrame or CNTV2C...">CNTV2Card::SetRegisterWriteMode</a>, which causes calls to <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11" title="Sets the input frame index number for the given FrameStore. This identifies which frame in device SDR...">CNTV2Card::SetInputFrame</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1f528a34e2c5a5b481b846434396a784" title="Sets the output frame index number for the given FrameStore. This identifies which frame in device SD...">CNTV2Card::SetOutputFrame</a> to take effect at the next <b>field</b> interrupt. In this mode of operation, the client application must wait for the next field interrupt – not frame interrupt – which gives it half the frame time to prepare/configure the device for the next field to be processed.</p>
<p>For progressive video, all syncs are flagged by the hardware as <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ae31d61e5f8328c58eb86af00d16e235daa8ad180541cbe234428f84b9f918cccc" title="Identifies the first field in time for an interlaced video frame, or the first and only field in a pr...">NTV2_FIELD0</a> syncs, so registers are updated for the next frame and the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1828395a3ecab209ad8a7a4ab5d9f5cf" title="Efficiently sleeps the calling thread/process until the next input VBI for the given field and input ...">CNTV2Card::WaitForInputFieldID</a> (or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac05240d99252c18d39dbdba3086ca72e" title="Efficiently sleeps the calling thread/process until the next output VBI for the given field and outpu...">CNTV2Card::WaitForOutputFieldID</a>) work as expected.</p>
<p>To wait for an event (such as a VBI) from a particular <b>FrameStore</b>, your application should subscribe to it by calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af4d4e2d89009d9ea923e7b9a7de0ea69" title="Causes me to be notified when an input vertical blanking interrupt occurs on the given input channel.">CNTV2Card::SubscribeInputVerticalEvent</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad24678dfaa1e5dc69114e178e67fa1da" title="Causes me to be notified when an output vertical blanking interrupt is generated for the given output...">CNTV2Card::SubscribeOutputVerticalEvent</a>.</p>
<p>Once subscribed, to efficiently wait for an input vertical interrupt, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1828395a3ecab209ad8a7a4ab5d9f5cf" title="Efficiently sleeps the calling thread/process until the next input VBI for the given field and input ...">CNTV2Card::WaitForInputFieldID</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a56552aedb9631efa04e1ff8ea96be02b" title="Efficiently sleeps the calling thread/process until the next one or more field (interlaced video) or ...">CNTV2Card::WaitForInputVerticalInterrupt</a>, referencing the <b>FrameStore</b> that’s configured for capture, and that’s routed (directly or indirectly) from an input that has a valid video signal.</p>
<p>To efficiently wait for an output vertical interrupt, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac05240d99252c18d39dbdba3086ca72e" title="Efficiently sleeps the calling thread/process until the next output VBI for the given field and outpu...">CNTV2Card::WaitForOutputFieldID</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0599dc483977c64978cae92fb8837252" title="Efficiently sleeps the calling thread/process until the next one or more field (interlaced video) or ...">CNTV2Card::WaitForOutputVerticalInterrupt</a>, referencing the <b>FrameStore</b> that’s configured for playout.</p>
<p>The number of input or output vertical events that have successfully been waited on and fired can be obtained by calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a305a4c0cc35cbf1bfa0c955504350770" title="Answers with the number of input interrupt events that I successfully waited for on the given channel...">CNTV2Card::GetInputVerticalEventCount</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#adc32fb598aace8739f4ff26b9e8b570b" title="Answers with the number of output interrupt events that I successfully waited for on the given channe...">CNTV2Card::GetOutputVerticalEventCount</a>. By calling either of these methods before and after calling the “wait for input/output” function, you can determine if the interrupt event actually triggered. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad6de950b980e17f4c129db09027d2db4" title="Resets my input interrupt event tally for the given channel.">CNTV2Card::SetInputVerticalEventCount</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0a0cdbbb0793f1f720b7e49dc9514876" title="Resets my output interrupt event tally for the given channel.">CNTV2Card::SetOutputVerticalEventCount</a> to reset the tally counter.</p>
<p>Normally it’s not necessary to explicitly unsubscribe the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html" title="I interrogate and control an AJA video/audio capture/playout device.">CNTV2Card</a> instance’s event subscriptions, as its destructor automatically does this when it calls <a class="el" href="../../d0/dbc/class_c_n_t_v2_driver_interface.html#a7b91c571a9d4856bef059df61655ca41" title="Closes me, releasing host resources that may have been allocated in a previous Open call.">CNTV2Card::Close</a>.</p>
<dl class="section note"><dt>Note</dt><dd>On the <b>Windows</b> platform, the AJA NTV2 driver stores a finite number of event subscription handles for client applications, which get consumed with every <b>Subscribe…</b> call (e.g. <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af4d4e2d89009d9ea923e7b9a7de0ea69" title="Causes me to be notified when an input vertical blanking interrupt occurs on the given input channel.">CNTV2Card::SubscribeInputVerticalEvent</a>, etc.), and are freed with every <b>Unsubscribe…</b> call (e.g. <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a70c45811d6556f29247575fa68cda7e5" title="Unregisters me so I&#39;m no longer notified when an input VBI is signaled on the given input channel.">CNTV2Card::UnsubscribeInputVerticalEvent</a>, etc.). Prior to SDK/driver version 16.2.3, abnormal program terminations, crashes, or force-quitting client apps from a debugger prevented the driver from freeing the subscription handles, which, after many repetitions, would exhaust the subscription handles. To recover from this, you had to…<ul>
<li>reboot the machine, or…</li>
<li>manually disable and re-enable the AJA driver (after closing all running NTV2 client applications, including the AJA Service, or…</li>
<li>set virtual register kVRegClearAllSubscriptions to a non-zero value (which can be easily done in <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> tool’s <a class="el" href="../../db/d02/toolsandutilities.html#inspectorregs">Registers Inspector</a> ). Starting in version 16.2.3, the driver now automatically unsubscribes and frees its subscribed event handles when the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html" title="I interrogate and control an AJA video/audio capture/playout device.">CNTV2Card</a> instance is destructed.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="vidop-fbconflict"></a>
When FrameStores Access the Same Frame Buffer Memory</h2>
<p>Note that it’s possible (and quite easy) to have two or more FrameStores accessing the same frame buffer memory.</p>
<p>Here’s an example where this would be really bad: </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="../../d2/d67/class_c_n_t_v2_device_scanner.html#a43517c9c7fedc4d199ef7616ce223276">CNTV2DeviceScanner::GetFirstDeviceFromArgument</a>(<span class="stringliteral">&quot;0&quot;</span>, device))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  Assume this device has valid video signals at SDI Inputs 1 and 2</span></div>
<div class="line">    <span class="comment">//  (same video format, different content)...</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a64a4c4087fa84101dba3a59f91c5ab31">ClearRouting</a>();  <span class="comment">//  Clear all existing connections</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">EnableChannel</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>);    <span class="comment">//  Enable FrameStore 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033">SetMode</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46">NTV2_MODE_CAPTURE</a>);   <span class="comment">//  Set FrameStore 1 to capture mode</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">SetSDITransmitEnable</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, <span class="keyword">false</span>);  <span class="comment">//  Set SDI connector 1 to capture</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">Connect</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4ac4aee26674a8a4ae84d209468d5333ee">NTV2_XptFrameBuffer1Input</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16aeb92ee9e88c84198ee883600cddaaa02">NTV2_XptSDIIn1</a>);  <span class="comment">//  Connect SDI In 1 to FrameStore 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11">SetInputFrame</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, 0); <span class="comment">//  Write FrameStore 1 video into frame buffer 0</span></div>
<div class="line"> </div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">EnableChannel</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>);    <span class="comment">//  Enable FrameStore 2</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033">SetMode</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46">NTV2_MODE_CAPTURE</a>);   <span class="comment">//  Set FrameStore 2 to capture mode</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">SetSDITransmitEnable</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, <span class="keyword">false</span>);  <span class="comment">//  Set SDI connector 2 to capture</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">Connect</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4a3b2b3698e844cbe676363f1a5d01363a">NTV2_XptFrameBuffer2Input</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16ab9a97db420ee0bfb6b34b156bb55ea6a">NTV2_XptSDIIn2</a>);  <span class="comment">//  Connect SDI In 2 to FrameStore 2</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11">SetInputFrame</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, 0); <span class="comment">//  Write FrameStore 2 video into frame buffer 0</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> In this case, there are two video signals fighting to write video rasters into the same frame memory on the device. If this frame were to be transferred to host memory, the image would look torn, a bad mixture of frames from SDI inputs 1 and 2.</p>
<p>On the other hand, FrameStores sharing the same frame buffer memory can be beneficial, for example, as a <b>Frame Synchronizer</b>. Here’s an example of how to synchronize an SDI signal with the AJA device’s free-running output clock: </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="../../d2/d67/class_c_n_t_v2_device_scanner.html#a43517c9c7fedc4d199ef7616ce223276">CNTV2DeviceScanner::GetFirstDeviceFromArgument</a>(<span class="stringliteral">&quot;0&quot;</span>, device))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  Assume this device has a valid video signal at SDI Input 1:</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a64a4c4087fa84101dba3a59f91c5ab31">ClearRouting</a>();  <span class="comment">//  Clear all existing connections</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">EnableChannel</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>);    <span class="comment">//  Enable FrameStore 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033">SetMode</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46">NTV2_MODE_CAPTURE</a>);   <span class="comment">//  Set FrameStore 1 to capture mode</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">SetSDITransmitEnable</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, <span class="keyword">false</span>);  <span class="comment">//  Set SDI connector 1 to capture</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">Connect</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4ac4aee26674a8a4ae84d209468d5333ee">NTV2_XptFrameBuffer1Input</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16aeb92ee9e88c84198ee883600cddaaa02">NTV2_XptSDIIn1</a>);  <span class="comment">//  Connect SDI In 1 to FrameStore 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11">SetInputFrame</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, 0); <span class="comment">//  Write FrameStore 1 video into frame buffer 0</span></div>
<div class="line"> </div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#af7ba7fb1976e09942caeb89219a396f8">SetReference</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa39fda6163a28fca5d7695e16f1dc9ecb">NTV2_REFERENCE_FREERUN</a>);    <span class="comment">//  Free run the outputs</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">EnableChannel</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>);    <span class="comment">//  Enable FrameStore 2</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033">SetMode</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5abec59926c3de1fac4acd02f438a2a634">NTV2_MODE_DISPLAY</a>);   <span class="comment">//  Set FrameStore 2 to playout mode</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a1f528a34e2c5a5b481b846434396a784">SetOutputFrame</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, 0);    <span class="comment">//  Read FrameStore 2 video from frame buffer 0</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">SetSDITransmitEnable</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcead307b257181bc49ad4e5e28f16b1a5c7">NTV2_CHANNEL3</a>, <span class="keyword">true</span>);   <span class="comment">//  Set SDI connector 3 to output</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">Connect</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4a04689c4ed3081db9cd6c99365285fc56">NTV2_XptSDIOut3Input</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16a408ad54d980889d663444647dea52d0a">NTV2_XptFrameBuffer2YUV</a>);  <span class="comment">//  Connect FrameStore 2’s output to SDI Out 3</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>When AutoCirculate is used, AutoCirculate manages the <b>FrameStore</b>’s <b>Input Frame</b> register (capture) or <b>Output Frame</b> register (playout), repeatedly circulating it from the <b>Start Frame</b> to the <b>End Frame</b> (e.g., 0 thu 6). Another <b>FrameStore</b> can very easily write into any of the frames involved in another <b>FrameStore</b>’s AutoCirculate frame range. For example: </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="../../d2/d67/class_c_n_t_v2_device_scanner.html#a43517c9c7fedc4d199ef7616ce223276">CNTV2DeviceScanner::GetFirstDeviceFromArgument</a>(<span class="stringliteral">&quot;0&quot;</span>, device))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  Assume this device has valid video signals at SDI Inputs 1 and 2</span></div>
<div class="line">    <span class="comment">//  (same video format, different content)...</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a64a4c4087fa84101dba3a59f91c5ab31">ClearRouting</a>();  <span class="comment">//  Clear all existing connections</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">EnableChannel</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>);    <span class="comment">//  Enable FrameStore 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">SetSDITransmitEnable</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, <span class="keyword">false</span>);  <span class="comment">//  Set SDI connector 1 to capture</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">Connect</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4ac4aee26674a8a4ae84d209468d5333ee">NTV2_XptFrameBuffer1Input</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16aeb92ee9e88c84198ee883600cddaaa02">NTV2_XptSDIIn1</a>);  <span class="comment">//  Connect SDI In 1 to FrameStore 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb">AutoCirculateInitForInput</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, 0, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516a3c7784bc2df30c1d0dbd8ca2717d27b8">NTV2_AUDIOSYSTEM_INVALID</a>, 0, 1, 0, 6);   <span class="comment">//  AutoCirculate capture into FBs 0/1/2/3/4/5/6</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#ae617507f1b0562f866201a58c26e10e7">AutoCirculateStart</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>);   <span class="comment">//  Start AutoCirculate (assume another thread calls AutoCirculateTransfer)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//  UH-OH:  This code block will cause 1 of every 7 frames captured via AutoCirculate</span></div>
<div class="line">    <span class="comment">//          on NTV2_CHANNEL1 to be corrupted by video from SDI Input 2...</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">EnableChannel</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>);    <span class="comment">//  Enable FrameStore 2</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033">SetMode</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46">NTV2_MODE_CAPTURE</a>);   <span class="comment">//  Set FrameStore 2 to capture mode</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">SetSDITransmitEnable</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, <span class="keyword">false</span>);  <span class="comment">//  Set SDI connector 2 to capture</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">Connect</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4a3b2b3698e844cbe676363f1a5d01363a">NTV2_XptFrameBuffer2Input</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16ab9a97db420ee0bfb6b34b156bb55ea6a">NTV2_XptSDIIn2</a>);  <span class="comment">//  Connect SDI In 2 to FrameStore 2</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11">SetInputFrame</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a>, 3); <span class="comment">//  Write FrameStore 2 video into frame buffer 3</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  size="50px" />
 <h2><a class="anchor" id="vidop-csc"></a>
Color Space Converter Operation</h2>
<p>A <b>Color Space Converter</b> (a.k.a. <b>CSC</b>) is a device widget implemented in FPGA firmware that converts YCbCr values into RGB[A] values, or vice-versa. It uses several registers to configure its conversion properties.</p>
<ul>
<li>Generally, there is one CSC for every SDI connector. <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a6834506c045cb2f3177728fc5374733d">NTV2DeviceGetNumCSCs</a> can be used to determine the number of CSCs on a given device, which should match <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ae8ebf28296f938a87237456a4a6866e0">NTV2DeviceGetNumVideoInputs</a> or <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a1c7b90df5e62610074a95589224057af">NTV2DeviceGetNumVideoOutputs</a> (whichever is larger).</li>
<li>CSC widgets are identified by <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a000096cdf1eb36b50c8e55c406f24befa7bf7220afa86d5dbefc8897e837d97f7">NTV2_WgtCSC1</a>, <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a000096cdf1eb36b50c8e55c406f24befaebc031a89d6e121de2bcd960a249092e">NTV2_WgtCSC2</a>, etc., but are normally identified in SDK calls by an <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dce" title="These enum values are mostly used to identify a specific Frame Store. They&#39;re also commonly used to i...">NTV2Channel</a> value that represents a zero-based index number.</li>
<li>Each CSC has two inputs:<ul>
<li><b>Video Input</b>: This input should be routed to another widget’s output that produces…<ul>
<li>YCbCr video — in which case the CSC will produce valid RGB[A] data at its <b>RGB Video</b> output.</li>
<li>RGB[A] video — in which case the CSC will produce valid YCbCr video at its <b>YUV Video</b> output, and alpha channel video at its <b>Key YUV</b> output.</li>
</ul>
</li>
<li><b>Key Input</b>: This supplies alpha channel data for the CSC’s <b>RGB Video</b> output. When used, it should always be sourced with YCbCr video (never RGB).</li>
</ul>
</li>
<li>Each CSC has 3 outputs:<ul>
<li><b>YUV Video</b>: This produces valid YCbCr video data only when the CSC’s <b>Video Input</b> is receiving RGB[A] video.</li>
<li><b>RGB Video</b>: This produces valid RGB[A] video data only when the CSC’s <b>Video Input</b> is receiving YCbCr video.</li>
<li><b>Key YUV</b>: This produces valid YCbCr key data only when the CSC’s <b>Video Input</b> is receiving RGB[A] video.</li>
</ul>
</li>
<li>Routing instructions are in the <a class="el" href="../../d0/dc3/ntv2signalrouting.html#widget_csc">ColorSpace Converter (CSC) Routing</a> section in the <a class="el" href="../../d0/dc3/ntv2signalrouting.html">Widget Signal Routing</a> section.</li>
<li>The CSC’s conversion coefficients are adjusted based on “SMPTE” versus “Full” range.<ul>
<li>The conversion range is represented in the SDK as the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a3bfea5bbaca99a345962333cf17b77e3">NTV2RGBBlackRange</a> or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a4c06fe6e0f62ce1363c933fc13311fff">NTV2_CSC_RGB_Range</a> data types.</li>
<li>Full range is represented by the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a4c06fe6e0f62ce1363c933fc13311fffaab69650250ac7b7d5b4f03b76821c252">NTV2_CSC_RGB_RANGE_FULL</a> or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a4c06fe6e0f62ce1363c933fc13311fffa9b8c97d4a0a9521744c9685b9db294d4">NTV2_RGBBLACKRANGE_0_0x3FF</a> enumerations.<ul>
<li>8-bit Full Range has 256 possible values (0 thru 255)</li>
<li>10-bit Full Range has 1024 possible values (0 thru 1023).</li>
</ul>
</li>
<li>SMPTE range is represented by the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a4c06fe6e0f62ce1363c933fc13311fffaab92ddccd6e41bb492fd4e0cc67f25c6">NTV2_CSC_RGB_RANGE_SMPTE</a> or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a4c06fe6e0f62ce1363c933fc13311fffa162dafe3d7328aee67e137311ec043be">NTV2_RGBBLACKRANGE_0x40_0x3C0</a> enumerations.<ul>
<li>8-bit SMPTE-range has 220 possible values (16 thru 235).</li>
<li>10-bit SMPTE-range has 877 possible values (64 thru 940).</li>
</ul>
</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0e537bc64b04896f8deb2af2eb25a51c" title="Answers with the current RGB range being used by a given CSC.">CNTV2Card::GetColorSpaceRGBBlackRange</a> to determine the current range setting for a CSC.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a41224b4e1398e2f154beddf1e429857f" title="Sets the RGB range for the given CSC.">CNTV2Card::SetColorSpaceRGBBlackRange</a> to change a CSC’s range setting.</li>
</ul>
</li>
<li>The CSC’s conversion matrix can be set to “Rec. 601” (SD) or “Rec. 709” (HD).<ul>
<li>The conversion matrix type is represented in the SDK by the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a1202f41a681e690d389191bf97b2c741">NTV2ColorSpaceMatrixType</a> data type.</li>
<li>Rec. 601 is represented by the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a1202f41a681e690d389191bf97b2c741af465d5edf030e24fa35704adc91d442e">NTV2_Rec601Matrix</a> enumeration constant.</li>
<li>Rec. 709 is represented by the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a1202f41a681e690d389191bf97b2c741aae9ad9246104952525c297bdd1e95acc">NTV2_Rec709Matrix</a> enumeration constant.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ace3277fa7657a2244316affd69106061" title="Answers with the current matrix type being used for the given CSC.">CNTV2Card::GetColorSpaceMatrixSelect</a> to determine the current matrix selection for a CSC.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac172cdae0fa11008b09a40e283f9b3fc" title="Sets the matrix type to be used for the given CSC, typically NTV2_Rec601Matrix or NTV2_Rec709Matrix.">CNTV2Card::SetColorSpaceMatrixSelect</a> to change a CSC’s matrix selection.</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>YCbCr to RGB Conversion</dt><dd></dd></dl>
<ul>
<li>When the CSC’s <b>Video Input</b> is connected to a YUV video source, it will convert and provide RGB data on its “RGB” output crosspoint.</li>
<li>In addition to the YCbCr-to-RGB value conversion, the CSC also performs the necessary 4:2:2 up-sampling to fill the “missing” pixels in the outgoing RGB raster.</li>
<li>The CSC will produce an <em>opaque</em> alpha channel by default.</li>
<li>It can produce alpha channel data from YCbCr video supplied to its <b>Key Input</b> (using just the luma channel) — provided it’s configured to do so:<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aa25018f2a3bc5e8c50b242ac5b807530" title="Answers whether or not the given CSC is set to produce alpha channel data from its key input.">CNTV2Card::GetColorSpaceMakeAlphaFromKey</a> to determine if the CSC will use its <b>Key Input</b> to generate alpha channel data.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#adaeb2f4f31c8a61d727be0f3d66b1eab" title="Specifies whether or not the given CSC will produce alpha channel data from its key input.">CNTV2Card::SetColorSpaceMakeAlphaFromKey</a> to enable or disable the setting.</li>
<li>When “Make Alpha From Key” is enabled, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a4d95e5138f1ff178eb57f9e671024c76" title="Answers whether or not the video signal present at the CSC’s Key Input is in sync with the video sign...">CNTV2Card::GetColorSpaceVideoKeySyncFail</a> to query if the CSC’s <b>Key Input</b> is synchronized with its <b>Video Input</b>. Sync failure will occur if the Key and Video signals have unrelated frame rates, or are significantly out of phase with each other.</li>
</ul>
</li>
</ul>
<p>The conversion formulæ: </p><div class="fragment"><div class="line"><span class="comment">// Full-range 8-bit “Rec 601” (SD) conversion:</span></div>
<div class="line">R = 1.164384 * y  +  0.000000 * cb  +  1.596027 * cr;</div>
<div class="line">G = 1.164384 * y  -  0.391762 * cb  -  0.812968 * cr;</div>
<div class="line">B = 1.164384 * y  +  2.017232 * cb  +  0.000000 * cr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SMPTE-range 8-bit “Rec 601” (SD) conversion:</span></div>
<div class="line">R = 1.000000 * y  +  0.000000 * cb  +  1.370705 * cr;</div>
<div class="line">R = 1.000000 * y  -  0.336455 * cb  -  0.698196 * cr;</div>
<div class="line">R = 1.000000 * y  +  1.732446 * cb  +  0.000000 * cr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Full-range 10-bit “Rec 601” (SD) conversion:</span></div>
<div class="line">R = 1.167808 * y  +  0.000000 * cb  +  1.600721 * cr;</div>
<div class="line">G = 1.167808 * y  -  0.392915 * cb  -  0.815359 * cr;</div>
<div class="line">B = 1.167808 * y  +  2.023165 * cb  +  0.000000 * cr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SMPTE-range 10-bit “Rec 601” (SD) conversion:</span></div>
<div class="line">R = 1.0000008 * y  +  0.000000 * cb  +  1.370705 * cr;</div>
<div class="line">G = 1.0000008 * y  -  0.336455 * cb  -  0.698196 * cr;</div>
<div class="line">B = 1.0000008 * y  +  1.732446 * cb  +  0.000000 * cr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Full-range 10-bit “Rec 709” (HD) conversion:</span></div>
<div class="line">R = 1.167808 * y  +  0.000000 * cb  +  1.798014 * cr;</div>
<div class="line">G = 1.167808 * y  -  0.213876 * cb  -  0.534477 * cr;</div>
<div class="line">B = 1.167808 * y  +  2.118615 * cb  +  0.000000 * cr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SMPTE-range 10-bit “Rec 709” (HD) conversion:</span></div>
<div class="line">R = 1.000000 * y  +  0.000000 * cb  +  1.539648 * cr;</div>
<div class="line">G = 1.000000 * y  -  0.183143 * cb  -  0.457675 * cr;</div>
<div class="line">B = 1.000000 * y  +  1.814180 * cb  +  0.000000 * cr;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The 8-bit and 10-bit coefficients are NOT the same, since the RGB 10-bit white point (1023) is not simply 4 × the 8-bit RGB white point (255).</dd></dl>
<dl class="section user"><dt>RGB to YCbCr Conversion</dt><dd></dd></dl>
<ul>
<li>When the CSC’s <b>Video Input</b> is fed RGB[A] video, it will convert and provide YUV data on its “Video” and “Key” output crosspoints.</li>
<li>In addition to the RGB-to-YCbCr value conversion, it also performs the necessary 4:2:2 down-sampling (implemented as a low-pass filter) for the fewer samples in the outgoing YUV raster.</li>
<li>The <b>Key Output</b> luma channel data is scaled appropriately from the incoming alpha channel data. Its outgoing Cb and Cr component values are fixed at <code>0x200</code>.</li>
</ul>
<p>The conversion formulæ: </p><div class="fragment"><div class="line"><span class="comment">// Full-range 10-bit “Rec 601” (SD) conversion:</span></div>
<div class="line">Y  =  0.25604 * r  +  0.50265 * g  +  0.09762 * b;</div>
<div class="line">Cb = -0.14779 * r  -  0.29014 * g  +  0.43793 * b;</div>
<div class="line">Cr =  0.43793 * r  -  0.36671 * g  -  0.07122 * b;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SMPTE-range 10-bit “Rec 601” (SD) conversion:</span></div>
<div class="line">Y  =  0.29900 * r  +  0.58700 * g  +  0.11400 * b;</div>
<div class="line">Cb = -0.17259 * r  -  0.33883 * g  +  0.51142 * b;</div>
<div class="line">Cr =  0.51142 * r  -  0.42825 * g  -  0.08317 * b;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Full-range 10-bit “Rec 709” (HD) conversion:</span></div>
<div class="line">Y  =  0.18205 * r  +  0.61243 * g  +  0.06183 * b;</div>
<div class="line">Cb = -0.10035 * r  -  0.33758 * g  +  0.43793 * b;</div>
<div class="line">Cr =  0.43793 * r  -  0.39777 * g  -  0.04016 * b;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SMPTE-range 10-bit “Rec 709” (HD) conversion:</span></div>
<div class="line">Y  =  0.21260 * r  +  0.71520 * g  +  0.07220 * b;</div>
<div class="line">Cb = -0.11719 * r  -  0.39423 * g  +  0.51142 * b;</div>
<div class="line">Cr =  0.51142 * r  -  0.46452 * g  -  0.04689 * b;</div>
</div><!-- fragment --><dl class="section user"><dt>Enhanced CSCs</dt><dd></dd></dl>
<p>Some AJA devices support “enhanced” CSC firmware that is used to override the default Rec 601 and Rec 709 conversion offsets and coefficients. Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a49a4a87c82f628552806c5a752d036a9">NTV2DeviceCanDoEnhancedCSC</a> to determine if the device has the enhanced CSC firmware.</p>
<hr  size="50px" />
 <h2><a class="anchor" id="vidop-lut"></a>
LUT Operation</h2>
<p>A color <b>Look Up Table</b> (a.k.a. <b>LUT</b>) is a device widget implemented in FPGA firmware that converts specific input RGB values into other corresponding RGB values. It uses several registers to configure its conversion properties and a contiguous bank of registers for reading or writing the conversion table.</p>
<dl class="section note"><dt>Note</dt><dd><b>LUT</b>s only work with RGB video, not YCbCr.</dd></dl>
<ul>
<li>For devices that have <b>LUT</b>s, there is usually one <b>LUT</b> for every <b>FrameStore</b> and/or SDI Input (or Output). Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a01972db7db21f60895b6fc4448945131">NTV2DeviceGetNumLUTs</a> to obtain the number of available <b>LUT</b>s.</li>
<li><b>LUT</b> widgets are identified by <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a000096cdf1eb36b50c8e55c406f24befa51341e61b0e190460ff3f0a46b544856">NTV2_WgtLUT1</a>, <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a000096cdf1eb36b50c8e55c406f24befa1626e992d0e9ee8f9773df1d4b6e1d84">NTV2_WgtLUT2</a>, …, but are normally identified in SDK calls by <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dce" title="These enum values are mostly used to identify a specific Frame Store. They&#39;re also commonly used to i...">NTV2Channel</a>, a zero-based, unsigned index number.</li>
<li>Each <b>LUT</b> widget has one input that only accepts RGB video.</li>
<li>Each <b>LUT</b> widget has two outputs — <b>YUV</b> and <b>RGB</b> — that carry the converted video. The <b>YUV</b> output carries the luminance of the converted video in the <b>Y</b> channel.</li>
<li>The <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ab46d920a53b380657f58ec8d602d3d35">NTV2DeviceGetLUTVersion</a> function returns the version number of the <b>LUT</b> widget firmware implementation.</li>
<li>The conversion is performed on a per-component basis using 10 bits of precision.</li>
<li>The 10-bit Red, Green, or Blue component value (<code>0x000</code> thru <code>0x3FF</code>) is used as the index into the respective R, G, or B table to fetch the converted output value, another 10-bit value in the range <code>0x000</code> thru <code>0x3FF</code>.</li>
<li><b>LUT</b>s have two independent banks, only one of which is actively converting input video.<ul>
<li>A bank is identified by an integer value — <b>0</b> or <b>1</b>.</li>
<li>To determine which bank is currently active for a given LUT, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2188c8d6d1dc03bf9014a4e7712106cd" title="Answers with the current LUT bank in use for the given LUT.">CNTV2Card::GetColorCorrectionOutputBank</a>.</li>
<li>To switch the active LUT bank, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a9080927104611c31dd94dceee7d4ab01" title="Sets the LUT bank to be used for the given LUT.">CNTV2Card::SetColorCorrectionOutputBank</a>.</li>
</ul>
</li>
<li>There is currently no API call that reads the Red, Green and/or Blue conversion table values for a particular bank of a given LUT. (It can be done, but a control register must be configured before and after calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ab80e8195b0bb0de13e99d1d4949b30e6" title="Reads the LUT tables (as raw, unsigned 10-bit integers).">CNTV2Card::ReadLUTTables</a>.)</li>
<li>To change the Red, Green and/or Blue conversion table values for a particular bank:<ul>
<li>Build a 1,024-element <code>std::vector</code> of <b>UWord</b> or <b>double</b> values for each R, G and/or B component. Each value in the array should be in the range <code>0 - 1023</code> or <code>0.00 - 1023.00</code>, respectively.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af0748f1f3b3a5a6abbdd96edc640ca85" title="Sends the given color lookup tables (LUTs) to the given LUT and bank.">CNTV2Card::DownloadLUTToHW</a>. The array values will automatically be clamped to the legal range <code>0x000</code> thru <code>0x3FF</code> prior to being written to the device.</li>
</ul>
</li>
<li>Some newer device firmware supports 12-bit LUTs. In 12-bit mode, the LUT table is expanded in size to 4,096 values per component, and the legal (output) values assume the range <code>0x000 - 0xFFF</code>.</li>
<li>See <a class="el" href="../../d0/dc3/ntv2signalrouting.html#widget_lut">LUT Routing</a> for a discussion on how to route signals to and from <b>LUT</b> widgets.</li>
<li>The <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> tool’s <a class="el" href="../../db/d02/toolsandutilities.html#inspectorlut">LUT Inspector</a> can be used to inspect and/or modify <b>LUT</b> configuration.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The reading and writing of any 10-bit “version 2” LUT bank table data flows through registers 512-2047, with host access controlled by register 376 (<code>kRegLUTV2Control</code>). There is no software mutex guarding access to this register, so calls to read or write the tables are not thread-safe.</dd></dl>
<hr  size="50px" />
 <h2><a class="anchor" id="vidop-mixerkeyer"></a>
Mixer/Keyer Operation</h2>
<p>A <b>Mixer/Keyer</b> is a device widget implemented in FPGA firmware that mixes or “keys” YCbCr video. It uses a pair of registers for configuring its mixing/keying properties.</p>
<dl class="section note"><dt>Note</dt><dd>Mixer/Keyer widgets can only process YCbCr video — not RGB[A].</dd></dl>
<ul>
<li>Generally, there is one mixer/keyer for every 2 FrameStores and/or SDI Inputs (or SDI Outputs). Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a90f54ca114d20b67bf98e6fc8d91acfb">NTV2DeviceGetNumMixers</a> to obtain the number of Mixer/Keyer widgets that are available.</li>
<li>Mixer/Keyer widgets are identified by <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a000096cdf1eb36b50c8e55c406f24befaf8acee6353e94d73b745e2135f098263">NTV2_WgtMixer1</a>, <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a000096cdf1eb36b50c8e55c406f24befae3e4d9630e8d155974763ddaffa2a596">NTV2_WgtMixer2</a>, …, but are normally identified in SDK calls by a zero-based, unsigned 16-bit index number.</li>
<li>Each Mixer/Keyer has two outputs — <b>Video</b> and <b>Key</b> — that contain the mixed/keyed output video.</li>
<li>Each Mixer/Keyer has four inputs:<ul>
<li>two <b>Foreground</b> inputs — <b>Video</b> and <b>Key</b> — and…</li>
<li>two <b>Background</b> inputs — <b>Video</b> and <b>Key</b>.</li>
<li><b>Key Input</b>s only utilize Y-channel data — the Cb and Cr components are ignored.</li>
<li><b>IMPORTANT:</b> The Mixer’s foreground and background inputs must be closely synchronized or the Mixer won’t be able to mix them. If the Mixer is unlocked, its outputs will send unclocked (garbage) video.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ab5f29f51bc010bebb27bd1837b60a481" title="Returns the current sync state of the given mixer/keyer.">CNTV2Card::GetMixerSyncStatus</a> to determine if the Mixer is locked to both of its inputs, and therefore if its output is valid.</li>
</ul>
</li>
</ul>
</li>
<li>Each Mixer/Keyer has the following configuration parameters:<ul>
<li><a class="el" href="../../d6/d0c/ntv2enums_8h.html#a256d27348cf30d190173284dc21c4a64" title="These enum values identify the mixer mode.">NTV2MixerKeyerMode</a> — Primary operating mode:<ul>
<li>Use <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a256d27348cf30d190173284dc21c4a64a4dca226371322e245fa3ceae304b9620" title="Passes only foreground video + key to the Mixer output.">NTV2MIXERMODE_FOREGROUND_ON</a> to exclusively pass the <b>foreground</b> video and key to the Mixer output.</li>
<li>Use <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a256d27348cf30d190173284dc21c4a64a3c181d1fa07a51a11e2e7661ec5e5ceb" title="Passes only background video + key to the Mixer output.">NTV2MIXERMODE_FOREGROUND_OFF</a> to exclusively pass the <b>background</b> video and key to the Mixer output.</li>
<li>Use <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a256d27348cf30d190173284dc21c4a64aec1b577c242e1776a571f1bcdf067a42" title="Overlays foreground video on top of background video.">NTV2MIXERMODE_MIX</a> to overlay the foreground video on top of the background video. Foreground or background <b>Flat Matte</b> (see below), if enabled, will be mixed instead of its respective input raster.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1ea0181003e09ec8bf5e2310ffff8849" title="Returns the current operating mode of the given mixer/keyer.">CNTV2Card::GetMixerMode</a> to determine the Mixer’s current mode.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad4777d0fd2bbf4f13ed36a8453a12f5f" title="Sets the mode for the given mixer/keyer.">CNTV2Card::SetMixerMode</a> to change its mode.</li>
</ul>
</li>
<li><a class="el" href="../../d6/d0c/ntv2enums_8h.html#aa0ebde37dced8c2ca3f066431de01a34" title="These enum values identify the Mixer/Keyer foreground and background input control values.">NTV2MixerKeyerInputControl</a> — input control mode, one for foreground input, one for background input:<ul>
<li><a class="el" href="../../d6/d0c/ntv2enums_8h.html#aa0ebde37dced8c2ca3f066431de01a34a4ee4c1e36dcb2934308f730c26fbf509">NTV2MIXERINPUTCONTROL_FULLRASTER</a> ignores the input key.</li>
<li><a class="el" href="../../d6/d0c/ntv2enums_8h.html#aa0ebde37dced8c2ca3f066431de01a34a7fa4cc77b838b95353cae2dff3d35f29">NTV2MIXERINPUTCONTROL_SHAPED</a> uses the input key as a mask.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a20cd2104f2bc06ba6dd82629e7726da1" title="Returns the current foreground input control value for the given mixer/keyer.">CNTV2Card::GetMixerFGInputControl</a> to discover the foreground input’s current control value.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#acabba54ea6b19e54226f94338a0a21bd" title="Sets the foreground input control value for the given mixer/keyer.">CNTV2Card::SetMixerFGInputControl</a> to change the foreground input’s control value.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad4b029c8e861b6a951a08aac049f14c2" title="Returns the current background input control value for the given mixer/keyer.">CNTV2Card::GetMixerBGInputControl</a> to discover the background input’s current control value.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a74813f1f79b59c069bdb2d3ec01a6dc9" title="Sets the background input control value for the given mixer/keyer.">CNTV2Card::SetMixerBGInputControl</a> to change the background input’s control value.</li>
</ul>
</li>
<li><b>Mix Coefficient</b> — an unsigned, 16-bit integer that determines the transparency of the foreground mask/key.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aa970d771e46667cf6105b63458e7de8b" title="Returns the current mix coefficient the given mixer/keyer.">CNTV2Card::GetMixerCoefficient</a> to determine the current mix coefficient value.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#abe18bb5ef0f35e15a6f58ccdf3756cb7" title="Sets the current mix coefficient of the given mixer/keyer.">CNTV2Card::SetMixerCoefficient</a> to change its value.</li>
</ul>
</li>
<li><b>Output VANC Source</b> — The Mixer’s output video VANC can be sourced from the foreground or background input video.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a490f7d16c35dba3c96ca1b4ec229bc34" title="Answers whether or not the VANC source for the given mixer/keyer is currently the foreground video....">CNTV2Card::GetMixerVancOutputFromForeground</a> to determine if the output VANC is currently being sourced from the foreground video input.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a30f025dc48cf0e407bc760657b81890d" title="Sets the VANC source for the given mixer/keyer to the foreground video (or not). See the Ancillary Da...">CNTV2Card::SetMixerVancOutputFromForeground</a> to change the output VANC source.</li>
</ul>
</li>
<li><b>Flat Matte</b> — The Mixer’s foreground or background raster can be set to a flat matte of any 10-bit YCbCr color. This matte will override any respective video input to the Mixer.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1730a44aa9900f6165f9ae3ddb3f7d39" title="Answers if the given mixer/keyer&#39;s foreground matte is enabled or not.">CNTV2Card::GetMixerFGMatteEnabled</a> to determine if the foreground matte is enabled or not.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a8def8c5f0b5180320fb8cd2e6c7eadb2" title="Answers if the given mixer/keyer&#39;s foreground matte is enabled or not.">CNTV2Card::SetMixerFGMatteEnabled</a> to enable or disable using the foreground matte.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad4502b5facb4bbc9a68011124ae8c950" title="Answers if the given mixer/keyer&#39;s background matte is enabled or not.">CNTV2Card::GetMixerBGMatteEnabled</a> to determine if the background matte is enabled or not.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a367adfa05454988606f781b8cad80c5c" title="Answers if the given mixer/keyer&#39;s background matte is enabled or not.">CNTV2Card::SetMixerBGMatteEnabled</a> to enable or disable using the background matte.</li>
<li>Do not enable <b>Flat Matte</b> on both foreground and background — use one or the other, or neither.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad933a3579aaaa32ff6278dc5c788bb50" title="Answers with the given mixer/keyer&#39;s current matte color value being used.">CNTV2Card::GetMixerMatteColor</a> to determine the current matte color.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aeedf3e488f5792123bac44126b242455" title="Sets the matte color to use for the given mixer/keyer.">CNTV2Card::SetMixerMatteColor</a> to change the matte color.</li>
<li>Note that to retain sync and enable its video output, the Mixer still requires a foreground video source if background matte is enabled, or a background video source if foreground matte is enabled.</li>
</ul>
</li>
</ul>
</li>
<li>For information on how to route signals to and from the Mixer, see <a class="el" href="../../d0/dc3/ntv2signalrouting.html#widget_mixkey">Mixer/Keyer Routing</a>.</li>
<li>The <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> tool’s <a class="el" href="../../db/d02/toolsandutilities.html#inspectormixerkeyer">Mixer/Keyer Inspector</a> allows you to interactively view each Mixer/Keyer widget’s current configuration, as well as make changes to it.</li>
</ul>
<hr  size="50px" />
 <h2><a class="anchor" id="vidop-hdr"></a>
High Dynamic Range (HDR) Video</h2>
<p>HDR support was introduced in SDK 12.5.</p>
<p><b>SDI output:</b> HDR data is delivered in-band using VPID signaling for SDR/HDR Transfer Characteristics, Colorimetry and Luminance.</p>
<p><b>HDMI output:</b> Side-band information is used to inform an HDMI sink device (e.g. a monitor) that the video content is HDR. This includes generation of the Dynamic Range and Mastering Info-frame and the static metadata descriptors as defined in CTA-861.3 and HDMI v2.0a.</p>
<p>Check the device page in <a class="el" href="../../d0/d53/ntv2devices.html">NTV2 Devices</a> for any notes on HDR support for a given device. You can also call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#af3b73d543cc047a8441c0cbc25aa2f4a">NTV2DeviceCanDoHDMIHDROut</a> to determine if the device's HDMI output is capable of HDR.</p>
<p>HLG and HDR10 parameters are formatted in the dynamic mastering info frame based on the HDR values passed to specific <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html" title="I interrogate and control an AJA video/audio capture/playout device.">CNTV2Card</a> functions (e.g. <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2777487c546f84c74e86a48bf61b28d4" title="Sets the Display Mastering data for White Point Y as defined in SMPTE ST 2086. This is Byte 17 and 18...">CNTV2Card::SetHDMIHDRWhitePointY</a>). The data does not need to be sequenced per-frame.</p>
<p>HDR10+ requires a vendor-specific info frame for each video frame. There is a way to pass custom HDMI info frames to the driver, however it was only a technology demonstration, and may not be supported in all drivers. Proper HDR10+ support is scheduled for a future SDK.</p>
<p><b>Dolby Vision</b> support was added in SDK 13.0. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7cd4eaed4bc779468fd24fe9f505bd42" title="Enables or disables HDMI HDR Dolby Vision.">CNTV2Card::EnableHDMIHDRDolbyVision</a> method to enable or disable sending the Dolby Vision bit in the HDMI AVI info frame to the monitor. Note that Dolby Vision data is encoded, and is output as 8-bit RGB, with the metadata in the least significant bits of the video at the top of the frame. (The actual video itself is actually 12-bit YUV 4:2:2.) Client applications must properly encode the Dolby Vision metadata into the host frame buffer before transferring it to the device during playback.</p>
<hr  size="50px" />
 <h1><a class="anchor" id="audiooperation"></a>
Audio System Operation</h1>
<p><b>Firmware Implementation</b></p><ul>
<li>An <b>Audio System</b> consists of:<ul>
<li>A Record engine that operates the <b>Capture</b> aspect of the <b>Audio System</b> (if <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ab5189daf688987b280922fb6cde1466f">NTV2DeviceCanDoCapture</a> returns <code>true</code>):<ul>
<li>when <em>Running</em>, continually writes audio samples into its 4MB input audio buffer region in device SDRAM, wrapping as necessary.</li>
<li>obtains audio samples from a designated source FIFO (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a286d834c8cad877d7e1bde2c3a761bba" title="Sets the audio source for the given NTV2AudioSystem on the device.">CNTV2Card::SetAudioSystemInputSource</a>).</li>
</ul>
</li>
<li>A Playback engine that operates the <b>Playout</b> aspect of the <b>Audio System</b> (if <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a2a59728d0474fc70c9887b81eecad127">NTV2DeviceCanDoPlayback</a> returns <code>true</code>):<ul>
<li>when <em>Running</em>, continually reads audio samples from its 4MB output audio buffer region in device SDRAM, wrapping as necessary.</li>
<li>can drive destination/output/sink FIFO(s);</li>
<li>always sends silence (zeroes) when <em>Stopped</em>.</li>
</ul>
</li>
<li>Several firmware registers are used to monitor and control each <b>Audio System</b>.</li>
</ul>
</li>
<li>Audio sources (inputs) and destinations (outputs) have FIFOs associated with them that pipe/stream their audio data to/from other sinks/sources.<ul>
<li>A source FIFO can drive an <b>Audio System</b>’s Record engine (for writing into device SDRAM), or it can feed another audio destination’s FIFO.</li>
<li>A destination (sink) FIFO can pull audio from an <b>Audio System</b>’s Playout engine (reading from device SDRAM), or it can pull from another audio source’s FIFO.</li>
<li>Depending on the transport chipset, they accommodate 2, 4, 8 or 16 channels of audio. Some are configurable (e.g. 2 or 8 channel HDMI audio).</li>
<li><b>SDI</b>:<ul>
<li>SDI inputs each have an <b>audio de-embedder</b> to decode incoming SMPTE 272M/299M HANC packets found in the input SDI stream, pushing audio into its (source) FIFO.</li>
<li>SDI outputs each have an <b>audio embedder</b> to encode and insert SMPTE 272M/299M HANC packets into the SDI stream, pulling audio from its (sink) FIFO.<ul>
<li>The SDI <b>audio embedder</b> can be turned off, if desired.</li>
<li>“Loopback” audio play-through is implemented by tying an output FIFO to an input FIFO (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a393cb3e27e8763bf52926ab1e0e70550" title="Enables or disables NTV2AudioLoopBack mode for the given NTV2AudioSystem.">CNTV2Card::SetAudioLoopBack</a>).</li>
</ul>
</li>
</ul>
</li>
<li><b>HDMI</b>, <b>AES/EBU</b> and <b>Analog</b> audio are handled similarly.<ul>
<li>Inputs <em>receive</em> audio, and <em>push</em> the samples into their associated source FIFO(s).</li>
<li>Outputs <em>transmit</em> audio, <em>pull</em>ing from their associated sink FIFO(s).</li>
</ul>
</li>
<li>There are bits in certain control registers that control where a destination/sink FIFO pulls its audio from.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>NTV2 devices with custom ancillary data extractors/inserters (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ad2b63b9f62be2e9793243832e62dabdd">NTV2DeviceCanDoCustomAnc</a>) make it possible to capture (and on some devices with special firmware, playback) SDI audio without using an <b>Audio System</b>, instead using the <a class="el" href="../../d7/dcb/ancillarydata.html#anccapture">Custom Anc Packet Capture</a> or <a class="el" href="../../d7/dcb/ancillarydata.html#ancplayout">Custom Anc Packet Playout</a> capabilities. Also note the <a class="el" href="../../d7/dcb/ancillarydata.html">Ancillary Data</a> facility won’t work for HDMI, AES/EBU or Analog transports — the <b>Audio System</b> facility must be used.</dd></dl>
<p><b>Audio Systems</b></p><ul>
<li>NTV2-compatible devices have a minimum of one <b>Audio System</b> (sometimes referred to in the past as an <b>Audio Engine</b>).</li>
<li>An <b>Audio System</b> can stream audio, whether in <b>Capture</b> (Record) mode, or <b>Playout</b> mode, or both.</li>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a22e624db258df962f03a1796e55c5c2b">NTV2DeviceGetNumAudioSystems</a> to determine the number of <b>Audio System</b>s on a device.</li>
</ul>
<p><b>Audio Channels</b></p><ul>
<li>Each <b>Audio System</b> can accommodate at least 8 channels of audio.</li>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a80b4d6a3ed7ee149586aa56ff2a5f618">NTV2DeviceGetMaxAudioChannels</a> to determine the maximum number of audio channels that a device’s <b>Audio System</b>s can handle.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af543923ef2fdbf75efe396d6868ac7cc" title="Returns the current number of audio channels being captured or played by a given Audio System on the ...">CNTV2Card::GetNumberAudioChannels</a> to determine how many audio channels a device <b>Audio System</b> is currently configured for.<ul>
<li>Modern AJA devices will accommodate up to 16 channels.</li>
<li>Very old AJA devices defaulted to 6 channels at power-up — these should be configured to use 8 channels.</li>
</ul>
</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a57a1348dd818107d730744c95c109e70" title="Sets the number of audio channels to be concurrently captured or played for a given Audio System on t...">CNTV2Card::SetNumberAudioChannels</a> to change the number of audio channels a device <b>Audio System</b> is configured to use. <dl class="section note"><dt>Note</dt><dd>AJA recommends configuring the <b>Audio System</b> to use the maximum number of audio channels the device is capable of.</dd></dl>
</li>
<li><b>HDMI Audio</b> — The HDMI standard supports a minimum baseline of 2 audio channels up to a maximum of 8.</li>
<li><b>AES/EBU Audio</b> — The AES/EBU connectors (on cables or breakout boxes) support 8 audio channels.</li>
<li><b>Analog Audio</b> — Analog audio connectors (on cables or breakout boxes) support 4 or 8 audio channels.</li>
<li><b>Monitor Audio</b> — Audio monitoring (RCA and/or headphone jacks) supports 2 audio channels.</li>
<li>The firmware automatically ensures that excess unused audio channels will capture silence or be ignored for playout. For example, an <b>Audio System</b> that’s been configured for 16 channels and is recording 2 HDMI audio channels will carry the HDMI audio in channels 1 and 2, and contain silence in channels 3 thru 16.</li>
<li>Note that some SDI video formats have substantially reduced HANC capacity, and thus can only carry 8 audio channels (e.g. 2K×1080@2997, 2K×1080@30, <a href="#" onclick="location.href='mai'+'lto:'+'4K@'+'29'+'.97'; return false;">4K@29<span style="display: none;">.nosp@m.</span>.97</a>, 4K@30). Again, the <b>Audio System</b> can still operate in 16-channel mode, but will capture and/or playout silence in channels 9-16.</li>
</ul>
<p><b>Audio Sample Rate</b></p><ul>
<li>The <b>Sample Rate</b> on all AJA devices is fixed at 48 kHz.</li>
<li>All NTV2 devices implement a 48 kHz <b>Audio Clock</b> that can be sampled through the <a class="el" href="../../d4/dd7/ntv2publicinterface_8h.html#a44465b2926268ea111cf5d357016baefab4cbf1377b1d2d7511773afa564d7a0a">kRegAud1Counter</a> register.<ul>
<li>This register is reset to zero at power-on and PCIe reset, and increments every 20.833… µs.</li>
<li>It’s used by <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> for precise timing purposes in <a class="el" href="../../d9/d09/class_f_r_a_m_e___s_t_a_m_p.html#a0d9e363d9c95e94f8134eff29869576a" title="Number of 10MHz ticks at moment of play or record, based on 48kHz clock (from register 28).">FRAME_STAMP::acAudioClockTimeStamp</a>, <a class="el" href="../../d9/d09/class_f_r_a_m_e___s_t_a_m_p.html#a3341ef5a1011d95884c000405b65bf67" title="Current time expressed as a count of 10MHz ticks, based on 48kHz clock (from register 28).">FRAME_STAMP::acAudioClockCurrentTime</a>, <a class="el" href="../../da/d18/class_a_u_t_o_c_i_r_c_u_l_a_t_e___s_t_a_t_u_s.html#abd8cb973bcd620ecb4120463fecc8809" title="Timestamp of the first VBI received after CNTV2Card::AutoCirculateStart called, using &quot;64-bit clean&quot; ...">AUTOCIRCULATE_STATUS::acAudioClockStartTime</a> and <a class="el" href="../../da/d18/class_a_u_t_o_c_i_r_c_u_l_a_t_e___s_t_a_t_u_s.html#ae40f6b6608454d93449936b85f1f29e1" title="Timestamp when CNTV2Card::AutoCirculateGetStatus called, using &quot;64-bit clean&quot; value of the device&#39;s 4...">AUTOCIRCULATE_STATUS::acAudioClockCurrentTime</a>.</li>
</ul>
</li>
</ul>
<p><b>Audio Buffers</b></p><ul>
<li>Each <b>Audio System</b> uses an 8 MB contiguous block of memory located in the upper part of SDRAM: <div class="image">
<img src="../../hwref-fig2-audiobuffers.png" alt=""/>
</div>
</li>
<li>An NTV2 device will use one of these two memory configurations for its <b>Audio System</b>s’ buffers:<ul>
<li>“Stacked” — The first <b>Audio System</b>’s 8 MB chunk starts at the very top of SDRAM, such that the last byte of <b>Audio System</b> 1’s <b>Input Buffer</b> coincides with the last addressable byte of SDRAM. Subsequent Audio Systems’ buffers stack downward from there, 8 MB each.</li>
<li>“Non-stacked” — These devices use the last one or two video frames for audio storage. The first byte of the last <b>Audio System</b>’s <b>Output Buffer</b> coincides with the first byte of the last frame buffer in device memory. Previous <b>Audio System</b> buffers, if any, start at the next-lower 8MB frame buffer.</li>
</ul>
</li>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ae561712c383551002a87e2b13a4d4296">NTV2DeviceCanDoStackedAudio</a> to determine if the device uses the “stacked” arrangement or not.</li>
<li>The first (lower address) 4 MB of the <b>Audio System</b>’s 8 MB chunk is for <b>Audio Output</b>.</li>
<li>The last (higher address) 4 MB of the <b>Audio System</b>’s 8 MB chunk is used for <b>Audio Input</b>.</li>
<li>Each Output or Input aspect of the <b>Audio System</b> operate independently, each being in one of two states:<ul>
<li><b>Stopped</b> — a.k.a. the “Reset” state.</li>
<li><b>Running</b> — When the Input or Output aspect of the <b>Audio System</b> is Running, eight or sixteen channels (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af543923ef2fdbf75efe396d6868ac7cc" title="Returns the current number of audio channels being captured or played by a given Audio System on the ...">CNTV2Card::GetNumberAudioChannels</a>) of audio are always written/read to/from this memory, regardless of whether all 8 or 16 channels are used.</li>
</ul>
</li>
<li>See <a class="el" href="../../d5/d32/dataformats.html#audioformats">Audio Data Formats</a> for details on the format of the audio data in the buffer.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Older “Non-stacked” audio devices (e.g. <a class="el" href="../../d0/d53/ntv2devices.html#konalhi">KONA LHi</a>) had audio systems that could operate with 1MB or 4MB buffers, and typically started (at power-up) in 1MB mode. This design was abandoned in favor of fixed 4MB buffers, which the NTV2 SDK generally assumes are in use. Applications that use “Non-stacked” devices are strongly recommended, when first configuring the device, to first call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aed29a4196efa4553703cb3199568f62e" title="Retrieves the size of the input or output audio buffer being used for a given Audio System on the AJA...">CNTV2Card::GetAudioBufferSize</a> to determine the current buffer size, and if it’s not 4MB, set it to 4MB mode by calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a9d6accfbf2f995aac91d16d16d150829" title="Changes the size of the audio buffer that is used for a given Audio System in the AJA device.">CNTV2Card::SetAudioBufferSize</a> with <a class="el" href="../../d6/d0c/ntv2enums_8h.html#af47d7e7811020a2ffdb7f9bf93510018af8e2e7e62fee29deba125cf9a7003928">NTV2_AUDIO_BUFFER_SIZE_4MB</a>. Before relinquishing control of the device, its prior (saved) buffer size should be restored.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is easy to write video data into an audio buffer and vice-versa, which leads to noisy, garbled audio and/or bad video frame(s). SDK clients must take precautions to ensure that frame buffers used by your application never coincide with any of the audio buffers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> tool’s <a class="el" href="../../db/d02/toolsandutilities.html#inspectoraudio">Audio Inspector</a> allows you to monitor each Audio System’s capture or playout buffer, as well as inspect or change its current configuration.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A fixed 4MB audio buffer necessarily places a maximum time limit … and therefore an upper limit on the number of frames of audio that can be buffered. For example, 4MB will hold up to 1.37 seconds of 16-channel audio, or 2.73 seconds of 8-channel audio. At 60 fps, that’s 82 or 164 frames, respectively; or at 29.97 fps, that’s 41 or 82 frames. Modern NTV2 devices have a large enough SDRAM complement such that it’s easy to buffer hundreds of video frames on the device, which can readily exceed the maximum frames of audio that can be buffered. <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb" title="Prepares for subsequent AutoCirculate ingest, designating a contiguous block of frame buffers on the ...">CNTV2Card::AutoCirculateInitForInput</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a669e0e26f156eacbba892e1520489f5c" title="Prepares for subsequent AutoCirculate playout, designating a contiguous block of frame buffers on the...">CNTV2Card::AutoCirculateInitForOutput</a> will emit a warning in <a class="el" href="../../db/d02/toolsandutilities.html#usingajalogger">“AJA Logger”</a> or the <a class="el" href="../../db/d02/toolsandutilities.html#usinglogreader">‘logreader’ Command-Line Utility</a> if the requested number of video frames to buffer exceeds the audio buffering capacity. (Be sure to enable the <code>AutoCirculate_39</code> message group to see these messages.)</dd></dl>
<hr  size="50px" />
 <h2><a class="anchor" id="audiocapture"></a>
Audio Capture</h2>
<p>For devices that are capable of capturing video, each <b>Audio System</b> constantly extracts audio samples from its <b>Input Source</b> (assuming the source is locked to a valid signal). If there’s no input signal, the <b>Audio System</b> invents zero values (silence) across all audio channels.</p><ul>
<li>Generally, the <b>Input Source</b> is selectable, to receive samples from any of the device’s video (and possibly audio) <b>Input Source</b>s, including embedded SDI, HDMI, external AES and analog inputs.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a729af0eaa2cf3ff98cc3aff683cc252b" title="Answers with the device&#39;s current NTV2AudioSource (and also possibly its NTV2EmbeddedAudioInput) for ...">CNTV2Card::GetAudioSystemInputSource</a> to determine the <b>Audio System</b>’s current <b>Input Source</b>.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a286d834c8cad877d7e1bde2c3a761bba" title="Sets the audio source for the given NTV2AudioSystem on the device.">CNTV2Card::SetAudioSystemInputSource</a> to change the <b>Audio System</b>’s <b>Input Source</b>.</li>
</ul>
</li>
<li><b>SDI Sources:</b> Audio samples are de-embedded from incoming audio HANC packets:<ul>
<li><b>HD:</b> follows SMPTE 299M: Each audio sample consists of 24 bits of sample data (normally PCM).</li>
<li><b>SD:</b> follows SMPTE 272M: Each audio sample consists of 20 bits of PCM sample data — audio extended packets are ignored.</li>
<li>For devices that support 3Gb Level B inputs, the audio can be taken from data stream 1 or 2.</li>
<li>Missing Embedded Audio Group packets (each containing two audio channel pairs) in the data stream result in silence (zeroes) for their respective audio channels.</li>
<li>The firmware continually notes which Embedded Audio Group packets are present and which are missing, and coalesces this information into a hardware register. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#abe1b024186f6653b0c182d088f03d968" title="Answers which audio channel pairs are present in the given Audio System&#39;s input stream.">CNTV2Card::GetDetectedAudioChannelPairs</a> to query this information.</li>
</ul>
</li>
<li><b>HDMI Sources:</b> Audio samples are pulled from the HDMI input hardware.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a52f5555d649caeebacd8b33c496e3e70" title="Answers with the current number of audio channels being received on the given HDMI input.">CNTV2Card::GetHDMIInputAudioChannels</a> to determine if the HDMI input is supplying 2 or 8 channels of audio.</li>
<li>Call CNTV2Card::SetHDMIInputAudioChannels to change the HDMI audio input configuration.</li>
</ul>
</li>
<li><b>AES:</b> Audio samples are obtained from the AES inputs.<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad2d71efa695adf2bcada02a4b2be8d51" title="Answers which AES/EBU audio channel pairs are present on the device.">CNTV2Card::GetDetectedAESChannelPairs</a> to determine which audio channel pairs have valid sample data.</li>
</ul>
</li>
<li><b>Analog:</b><ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a5f102a5e31c734658c3dbceba84738da">NTV2DeviceGetNumAnalogAudioInputChannels</a> to determine if the device can capture analog audio, and if so, the maximum number of audio channels.</li>
<li>On devices that support 2 channels of analog audio, audio samples for audio channels 1&amp;2 are obtained from the analog video input.</li>
<li>Some devices that support analog audio input through a breakout box or cable (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a65a3b8207806dc5f4f54c5b011489c9d">NTV2DeviceCanDoBreakoutBox</a> and <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a5f102a5e31c734658c3dbceba84738da">NTV2DeviceGetNumAnalogAudioInputChannels</a> functions) have bi-directional analog XLR connectors. Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a257f82e038f8d1adeb7b608e91b23903">NTV2DeviceHasBiDirectionalAnalogAudio</a> to determine if this is true, and if so:<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af39f58b55895653791913b3d3e9b0902" title="Answers whether or not the specified bidirectional XLR audio connectors are collectively acting as in...">CNTV2Card::GetAnalogAudioTransmitEnable</a> to discover if a given XLR quad (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#a02f78fba0c2d1f8930ae89d58cfba4c4" title="Identifies a contiguous, adjacent group of four audio channels.">NTV2Audio4ChannelSelect</a>) is configured for output or input.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a8942d73022b3a042f3790a040a368162" title="Sets the specified bidirectional XLR audio connectors to collectively act as inputs or outputs.">CNTV2Card::SetAnalogAudioTransmitEnable</a> to configure a given XLR quad (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#a02f78fba0c2d1f8930ae89d58cfba4c4" title="Identifies a contiguous, adjacent group of four audio channels.">NTV2Audio4ChannelSelect</a>) for input by passing <em>false</em> for <em>inEnable</em>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>When the <b>Audio System</b> is running, each 24-bit sample is copied as-is into the most-significant 3 bytes of each 4-byte sample word in the <b>Audio Input Buffer</b> in device memory at the address specified by the <b>Audio System</b>’s Audio Input Last Address register (i.e., the <b>Record Head</b> or “write head”).</p><ul>
<li>On older (non-stacked-audio) devices, this sample-copying process is done in 128-byte chunks.</li>
<li>On newer (stacked-audio) devices, 512-byte chunks are used.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#abd4414dee29a0ce3926e60a16640a58c" title="Answers whether or not the capture side of the given NTV2AudioSystem is currently running.">CNTV2Card::IsAudioInputRunning</a> to determine if the capture side of the <b>Audio System</b> is running or not.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7bb3f4860af9fed53c7eacb54d0d3d60" title="Starts the capture side of the given NTV2AudioSystem, writing incoming audio samples into the Audio S...">CNTV2Card::StartAudioInput</a> to start the capture aspect of the <b>Audio System</b> running.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a6d1519dde79a3f075fb1d66a6c0bbbb1" title="Stops the capture side of the given NTV2AudioSystem, and resets the capture position (i....">CNTV2Card::StopAudioInput</a> to stop the capture aspect of the <b>Audio System</b> running.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad63a16a55b6124ea8374d2a240e0825f" title="Enables or disables the writing of incoming audio into the given Audio System&#39;s capture buffer.">CNTV2Card::SetAudioCaptureEnable</a> to enable or disable writing into the <b>Audio System</b>’s <b>Input Buffer</b> memory. Note that <b>Input Buffer</b> writing can be disabled while the <b>Audio System</b> is running — the <b>Audio System</b> will continue to go through the motions of Capture, advancing the <b>Record Head</b> as needed, but the <b>Input Buffer</b>’s contents won’t change.</li>
</ul>
<p>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac4a3d2c59a3f2a407e39e8f9619067dd" title="For the given Audio System, answers with the byte offset to the last byte of the latest chunk of 4-by...">CNTV2Card::ReadAudioLastIn</a> to obtain the current <b>Record Head</b> position. Audio data continues to be written into the <b>Input Buffer</b> until filled, whereupon the <b>Record Head</b> wraps back to the start of the buffer, where writing continues. The least-significant byte of each 32-bit sample word in the <b>Audio Input Buffer</b> is always set to zero. (Note that for SD, because extended packets are ignored, an extra 4-bit nibble in each 32-bit sample word will also be zero.)</p>
<div class="image">
<img src="../../hwref-fig3-audiorecordplay.png" alt=""/>
</div>
<p>Audio data can be transferred from the <b>Audio Input Buffer</b> in device memory to a host audio buffer via DMA by calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a22455787104622d71a11d1638cb74c0f" title="Synchronously transfers audio data from a given Audio System&#39;s buffer memory on the AJA device to the...">CNTV2Card::DMAReadAudio</a>. While the offset to the Input portion of the device Audio Buffer is typically fixed at 4 MB, to be absolutely safe should this ever change, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0c966f26eb0874c2e520ebda89c5197b" title="For the given Audio System, answers with the byte offset from the start of the audio buffer to the fi...">CNTV2Card::GetAudioReadOffset</a> to obtain the actual offset being used by the driver and SDK.</p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> is used for capture, <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> completely and automatically runs the <b>Audio System</b> — there is no need to call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7bb3f4860af9fed53c7eacb54d0d3d60" title="Starts the capture side of the given NTV2AudioSystem, writing incoming audio samples into the Audio S...">CNTV2Card::StartAudioInput</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad63a16a55b6124ea8374d2a240e0825f" title="Enables or disables the writing of incoming audio into the given Audio System&#39;s capture buffer.">CNTV2Card::SetAudioCaptureEnable</a>. When <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb" title="Prepares for subsequent AutoCirculate ingest, designating a contiguous block of frame buffers on the ...">CNTV2Card::AutoCirculateInitForInput</a> is called with a valid <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a>, and <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ae617507f1b0562f866201a58c26e10e7" title="Starts AutoCirculating the specified channel that was previously initialized by CNTV2Card::AutoCircul...">CNTV2Card::AutoCirculateStart</a> is subsequently called, <a class="el" href="../../d9/d9a/recordplaytechniques.html#aboutautocirculate">AutoCirculate</a> starts the <b>Audio System</b>. <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a> automatically transfers the correct number of captured audio samples from the device Audio System’s <b>Input Buffer</b> that are associated with the video frame being transferred. <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#ad5b65a78cb290a12684696c031d72f75">AUTOCIRCULATE_TRANSFER::GetCapturedAudioByteCount</a> will return the exact number of transferred audio bytes for the frame that was just transferred to the host. See <a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculatecapture">AutoCirculate Capture</a> for more information.</dd></dl>
<p>Upstream equipment may indicate one or more audio channel pairs is not carrying PCM data (e.g., Dolby-E) via certain bits in the AES header in the audio stream. On newer AJA devices (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a7b524f4795ee269ecb6eb1e0d26aaba5">NTV2DeviceCanDoPCMDetection</a>), the <b>Audio System</b>’s de-embedder makes this information available in a hardware register, and client software can query it by calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2659ba98795fb242aa0b796476b5fd04" title="For the given SDI input (specified as a channel number), returns the set of audio channel pairs that ...">CNTV2Card::GetInputAudioChannelPairsWithoutPCM</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#acf95497150226854f0c543da3f60b912" title="For the given SDI input (specified as a channel number), answers if the specified audio channel pair ...">CNTV2Card::InputAudioChannelPairHasPCM</a>.</p>
<dl class="section note"><dt>Note</dt><dd><b>Dolby AC-3</b>, for example, per SMPTE ST-337, is transported as non-PCM data in the SDI AES stream. The AC-3 data is located in the PCM audio sample words of a channel pair — see <a class="el" href="../../d5/d32/dataformats.html#audioformats">Audio Data Formats</a> . The formatting of the AC-3 data into the channel pairs is quite flexible, but usually a channel pair (e.g. 5&amp;6) is considered a single AC-3 stream. The specification allows AC-3 data to be carried in 16, 20 or 24 bits of the PCM sample. This flexibility requires the application to know how the source has formatted the data into the AES samples.</dd></dl>
<p>Newer AJA hardware firmware implements an adjustable input delay that can be applied while samples are being written into the <b>Audio Input Buffer</b>. Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#af7be7785209c6dd7e0b2e09b60a8452b">NTV2DeviceCanDoAudioDelay</a> to determine if this feature is available. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a5fb4d6e2f1a445c1a6eeb4b09a91ca50" title="Answers with the audio input delay for the given Audio System on the device.">CNTV2Card::GetAudioInputDelay</a> to obtain the current delay value. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1df63d77eeb293847fa7c4f11bc9f5cd" title="Sets the audio input delay for the given Audio System on the device.">CNTV2Card::SetAudioInputDelay</a> to change it.</p>
<p>Audio input clocking for the running <b>Audio System</b> is ordinarily obtained from the input signal being used (SDI, HDMI, Analog, etc.). AJA’s older devices, however, derived the audio input clock from the Device Reference by default (see <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9df" title="These enum values identify a specific source for the device&#39;s (output) reference clock.">NTV2ReferenceSource</a>) and had to be explicitly configured to use the input signal by passing <a class="el" href="../../d6/d0c/ntv2enums_8h.html#ac492d503b9fec4eccd48c573f795a7daa93b2d229d398783c88324b5e9b46d632" title="Audio clock derived from the video input.">NTV2_EMBEDDED_AUDIO_CLOCK_VIDEO_INPUT</a> to <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ae833463985c8b5780963baaa8f426014" title="Sets the NTV2EmbeddedAudioClock setting for the given NTV2AudioSystem.">CNTV2Card::SetEmbeddedAudioClock</a>. If this wasn’t done, and the board reference was <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa39fda6163a28fca5d7695e16f1dc9ecb" title="Specifies the device&#39;s internal clock.">NTV2_REFERENCE_FREERUN</a> or some other timebase that differed from the input video signal, the audio would eventually drift from the video. (See also <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#aff20455a48fa9340ff2156ca3bee4928">NTV2DeviceCanChangeEmbeddedAudioClock</a>.)</p>
<hr  size="50px" />
 <h2><a class="anchor" id="audioplayout"></a>
Audio Playout</h2>
<p>If the device supports SDI playout, each <b>Audio System</b> has an output embedder that generates audio packets (per SMPTE 299M for HD and SMPTE 272M for SD) and inserts them into the HANC area of the outgoing SDI data stream.</p><ul>
<li>Audio channels 1 &amp; 2 are transmitted on Embedded Group 1, channels 1 &amp; 2.</li>
<li>Audio channels 3 &amp; 4 are transmitted on Embedded Group 1, channels 3 &amp; 4.</li>
<li>Audio channels 5 &amp; 6 are transmitted on Embedded Group 2, channels 1 &amp; 2.</li>
<li>Audio channels 7 &amp; 8 are transmitted on Embedded Group 2, channels 3 &amp; 4.</li>
<li>In 16-channel mode (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af543923ef2fdbf75efe396d6868ac7cc" title="Returns the current number of audio channels being captured or played by a given Audio System on the ...">CNTV2Card::GetNumberAudioChannels</a>), the remaining 8 channels are distributed in Embedded Groups 3 and 4 in a similar fashion.</li>
</ul>
<p>There is currently no provision for enabling or disabling specific audio groups.</p>
<p>The SDI output embedder always inserts audio packets unless it’s been disabled (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aba23f404d2607225abaab3ee02cf84da" title="Enables or disables the audio output embedder for the given SDI output connector (specified as a chan...">CNTV2Card::SetAudioOutputEmbedderState</a>).</p>
<p>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a4cf4089fc092af267a96d5c11de114f2" title="Answers whether or not the playout side of the given NTV2AudioSystem is currently running.">CNTV2Card::IsAudioOutputRunning</a> to determine if the playout side of the <b>Audio System</b> is running or not. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3a9f9d2669ee89b7932b32e8821126d2" title="Starts the playout side of the given NTV2AudioSystem, reading outgoing audio samples from the Audio S...">CNTV2Card::StartAudioOutput</a> to start the playout side of the <b>Audio System</b> running. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#abb6d1c8d1a4691e66d85d3eb956da7ea" title="Stops the playout side of the given NTV2AudioSystem, parking the &quot;Read Head&quot; at the start of the play...">CNTV2Card::StopAudioOutput</a> to stop the playout side of the <b>Audio System</b> running.</p>
<p>When the <b>Audio System</b> is stopped, the output embedder will either embed silence (zeroes) into the data stream, or, if <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a790796fdf3b5603bf8808f56a72cfbc3" title="This enum value determines/states if an audio output embedder will embed silence (zeroes) or de-embed...">NTV2AudioLoopBack</a> mode is enabled, it will embed audio samples obtained (through a FIFO) from its input de-embedder (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a393cb3e27e8763bf52926ab1e0e70550" title="Enables or disables NTV2AudioLoopBack mode for the given NTV2AudioSystem.">CNTV2Card::SetAudioLoopBack</a>).</p>
<p>When the <b>Audio System</b> is running, each 24-bit audio sample is copied from the most-significant 3 bytes of each 32-bit longword in the device audio buffer (the least-significant byte is ignored). Note, however, for <b>SD</b>, only the most-significant 20 bits are used (since the embedder does not create extended audio packets).</p>
<p>During playout, the output embedder pulls audio samples from the <b>Audio Output Buffer</b> in device memory at the address specified by the <b>Audio System</b>’s <b>Audio Output Last Address</b> register (i.e., the <b>Play Head</b> or “read head”). On older, non-stacked-audio devices, this is done in 128-byte chunks. On newer, stacked-audio devices, it’s done in 512-byte chunks.</p>
<p>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3d28e351567379e011189fce0f184f18" title="For the given Audio System, answers with the byte offset of the tail end of the last chunk of audio s...">CNTV2Card::ReadAudioLastOut</a> to get the current <b>Play Head</b> position. Audio data continues to be read from the <b>Output Buffer</b> until the end is reached, whereupon the <b>Play Head</b> wraps back to the start of the buffer, where reading continues.</p>
<p><b>Startup Delay:</b> Ordinarily, when playout starts, the Audio System immediately starts pulling samples from the <b>Audio Output Buffer</b>, encoding them into audio packets and embedding those first several packets into the current outgoing video frame, often mid-frame, preceded by a number of packets containing silence. This makes it difficult for applications to precisely determine the location of frame breaks in the <b>Audio Output Buffer</b>. Starting in SDK 15.6, and using newer AJA hardware and firmware (see CNTV2Card::CanDoAudioWaitForVBI), <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3a9f9d2669ee89b7932b32e8821126d2" title="Starts the playout side of the given NTV2AudioSystem, reading outgoing audio samples from the Audio S...">CNTV2Card::StartAudioOutput</a> has an optional “<em>waitForVBI</em>” parameter that if set <code>True</code>, causes the firmware to delay starting Audio Playout until the next output VBI, so that the first samples from the <b>Audio Output Buffer</b> end up in the first audio packets in the next outgoing video frame.</p>
<p><b>Output Delay:</b> Newer AJA hardware firmware implements an adjustable <b>Output Delay</b> that can be applied while samples are being read from the <b>Audio Output Buffer</b>. Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#af7be7785209c6dd7e0b2e09b60a8452b">NTV2DeviceCanDoAudioDelay</a> to determine if this feature is available. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a5d17fde68792dff0bc6002d3cc0b10ef" title="Answers with the audio output delay for the given Audio System on the device.">CNTV2Card::GetAudioOutputDelay</a> to obtain the current delay value. Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a1f293ffa93ad0299a555a68956a5bdaa" title="Sets the audio output delay for the given Audio System on the device.">CNTV2Card::SetAudioOutputDelay</a> to change it.</p>
<p><b>Erase Mode:</b> The playout engine has an optional <b>Erase Mode</b>, in which it will automatically clear (zero) the <b>Output Buffer</b> memory immediately behind the <b>Play Head</b> as it runs. If the host application fails to transfer new samples into the <b>Audio Output Buffer</b>, the buffer will eventually contain all zeroes, and the output embedder will thereafter only transmit silence. Use the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7554d120505204b9e6f9e4adb3fb72a4" title="Enables or disables output erase mode for the given Audio System, which, when enabled,...">CNTV2Card::SetAudioOutputEraseMode</a> function to configure this feature.</p>
<p><b>DMA Transfer:</b> Audio data can be transferred from the host to the device audio buffer via DMA by calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af476915ad0be7fce076370af2130a7d9" title="Synchronously transfers audio data from the specified host buffer to the given Audio System&#39;s buffer ...">CNTV2Card::DMAWriteAudio</a>. If the playout engine’s hardware <b>Play Head</b> catches up to, or passes, the buffer region being written by <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af476915ad0be7fce076370af2130a7d9" title="Synchronously transfers audio data from the specified host buffer to the given Audio System&#39;s buffer ...">CNTV2Card::DMAWriteAudio</a>, then audio/video synchronization has been lost. Care must be taken to ensure that enough samples are always written well ahead of the <b>Play Head</b>.</p>
<p>There is no provision for changing the <b>Play Head</b> position while <b>Audio System</b> playback is running … except perhaps to reset playback to the start of the audio buffer (by calling both <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#abb6d1c8d1a4691e66d85d3eb956da7ea" title="Stops the playout side of the given NTV2AudioSystem, parking the &quot;Read Head&quot; at the start of the play...">CNTV2Card::StopAudioOutput</a> and then <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3a9f9d2669ee89b7932b32e8821126d2" title="Starts the playout side of the given NTV2AudioSystem, reading outgoing audio samples from the Audio S...">CNTV2Card::StartAudioOutput</a>). Of course, applications have full control over the number of samples written, and where they get written into the <b>Audio Output Buffer</b>. Applications are free to drop samples or add silence as needed, while always ensuring these transfers stay ahead of the <b>Play Head</b>.</p>
<p>If <a class="el" href="../../d9/d9a/recordplaytechniques.html#autocirculateplayout">AutoCirculate Playout</a> is being used, AutoCirculate completely and automatically runs the <b>Audio System</b>. When <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a669e0e26f156eacbba892e1520489f5c" title="Prepares for subsequent AutoCirculate playout, designating a contiguous block of frame buffers on the...">CNTV2Card::AutoCirculateInitForOutput</a> is called with a valid <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a>, and then <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ae617507f1b0562f866201a58c26e10e7" title="Starts AutoCirculating the specified channel that was previously initialized by CNTV2Card::AutoCircul...">CNTV2Card::AutoCirculateStart</a> is called, AutoCirculate starts the <b>Audio System</b>. Youʼll need to transfer the correct number of audio samples via <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#adc7e3eb26eb326ffe273b5f3308dcdb6" title="Sets my audio buffer for use in a subsequent call to CNTV2Card::AutoCirculateTransfer.">AUTOCIRCULATE_TRANSFER::SetAudioBuffer</a> or <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#a43e5bdd953b93d505ddfe2ce58451adc" title="The host audio buffer. This field is owned by the client application, and thus is responsible for all...">AUTOCIRCULATE_TRANSFER::acAudioBuffer</a> before calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a>. See <a class="el" href="../../d1/dc5/ntv2devops.html#audiosamplecount">Correlating Audio Samples to Video Frames</a> (below) on how to calculate the correct number of audio samples for the current outgoing frame.</p>
<p><b>SDI Output:</b> SDI output embedders can ordinarily be driven by any <b>Audio System</b>.</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ab195cb933b4f812fc6ff57e7a8b07d7f" title="Answers with the device&#39;s NTV2AudioSystem that is currently providing audio for the given SDI output&#39;...">CNTV2Card::GetSDIOutputAudioSystem</a> to determine which Audio System is currently driving Data Stream 1.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a692c2f8b747962d58df9ed2dbc0a9074" title="Sets the device&#39;s NTV2AudioSystem that will provide audio for the given SDI output&#39;s audio embedder....">CNTV2Card::SetSDIOutputAudioSystem</a> to change DS1’s Audio System.</li>
<li>On devices that have 3G/6G/12G SDI connectors that support Dual Link output:<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a36f832d7bff9146754d38c1d7788982e" title="Answers with the device&#39;s Audio System that is currently providing audio for the given SDI output&#39;s a...">CNTV2Card::GetSDIOutputDS2AudioSystem</a> to determine the Audio System that’s currently driving Data Stream 2.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a5d85a46821170dfcd356286d96e2478f" title="Sets the Audio System that will supply audio for the given SDI output&#39;s audio embedder for Data Strea...">CNTV2Card::SetSDIOutputDS2AudioSystem</a> to change DS2’s Audio System.</li>
</ul>
</li>
</ul>
<p><b>HDMI Output:</b> The HDMI standard supports a minimum of 2 audio channels or a maximum of 8. If the NTV2 device has an HDMI output (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#aef10706f5b1fc8d00d810c6d664d3d59">NTV2DeviceGetNumHDMIVideoOutputs</a> ), it can be configured to transmit audio from any <b>Audio System</b>:</p><ul>
<li>To transmit 2 audio channels, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a612ee338d58206ee36042c25e649a454" title="Sets the HDMI output&#39;s 2-channel audio source.">CNTV2Card::SetHDMIOutAudioSource2Channel</a> :<ul>
<li>Specify the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> that will drive the HDMI outputʼs audio;</li>
<li>Specify the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a3a847dd1ee3bbe9b15985a9706b6a483" title="Identifies a pair of audio channels.">NTV2AudioChannelPair</a> that will determine which two of the Audio Systemʼs 8 (or 16) audio channels will be used.</li>
</ul>
</li>
<li>To transmit 8 audio channels, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7021378f090393ed6636e7fc5fd04cbb" title="Changes the HDMI output&#39;s 8-channel audio source.">CNTV2Card::SetHDMIOutAudioSource8Channel</a> :<ul>
<li>Specify the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> that will drive the HDMI outputʼs audio;</li>
<li>Specify the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aa75890ce396346710239671299ee687f" title="Identifies a contiguous, adjacent group of eight audio channels.">NTV2Audio8ChannelSelect</a> that will determine which group of 8 contiguous channels will be used from the Audio Systemʼs (presumably) 16 channels.</li>
</ul>
</li>
</ul>
<p><b>AES/EBU Output:</b> For devices that support AES/EBU output through a breakout box or cable (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a65a3b8207806dc5f4f54c5b011489c9d">NTV2DeviceCanDoBreakoutBox</a> and <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ac0cb51e349cd5d7a323da96e5a51c0c8">NTV2DeviceGetNumAESAudioOutputChannels</a> functions), the output BNCs will automatically carry the same per-audio-channel samples being played/embedded from <b>Audio Sytem 1</b> (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516aa7306a07c062c3733dcc53b3b5e898d0" title="This identifies the first Audio System.">NTV2_AUDIOSYSTEM_1</a>). This can be changed to use a different set of 4 audio channels, even from a different <b>Audio System</b> (if available).</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a9f11a601e6dd7d6e29733e3cce9a8318" title="Answers with the current audio source for a given quad of AES audio output channels....">CNTV2Card::GetAESOutputSource</a> to determine the current <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> and <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a02f78fba0c2d1f8930ae89d58cfba4c4" title="Identifies a contiguous, adjacent group of four audio channels.">NTV2Audio4ChannelSelect</a> (a contiguous band of 4 audio channels) being used for a given set of 4 AES audio channels.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad4ea543603dd1b0c82d0b448458e0251" title="Changes the audio source for the given quad of AES audio output channels. By default,...">CNTV2Card::SetAESOutputSource</a> to set the 4 audio channels and/or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> to be used for a given set of 4 AES audio channels.</li>
</ul>
<p><b>Analog Output:</b> For devices that support analog audio output through a breakout box or cable (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a65a3b8207806dc5f4f54c5b011489c9d">NTV2DeviceCanDoBreakoutBox</a> and <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a75ff73bfda8289762b0a60d6b45655bb">NTV2DeviceGetNumAnalogAudioOutputChannels</a> functions), the output XLRs follow whatʼs being carried by the <b>AES/EBU Output</b>s (above).</p><ul>
<li>Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a75ff73bfda8289762b0a60d6b45655bb">NTV2DeviceGetNumAnalogAudioOutputChannels</a> to determine if the device can output analog audio, and if so, the maximum number of audio channels it supports.</li>
<li>Some devices have bi-directional analog XLR connectors. Call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a257f82e038f8d1adeb7b608e91b23903">NTV2DeviceHasBiDirectionalAnalogAudio</a> to determine if this is true. For these bi-directional XLRs:<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#af39f58b55895653791913b3d3e9b0902" title="Answers whether or not the specified bidirectional XLR audio connectors are collectively acting as in...">CNTV2Card::GetAnalogAudioTransmitEnable</a> to discover if a given XLR quad (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#a02f78fba0c2d1f8930ae89d58cfba4c4" title="Identifies a contiguous, adjacent group of four audio channels.">NTV2Audio4ChannelSelect</a>) is configured for output or input.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a8942d73022b3a042f3790a040a368162" title="Sets the specified bidirectional XLR audio connectors to collectively act as inputs or outputs.">CNTV2Card::SetAnalogAudioTransmitEnable</a> to configure a given XLR quad (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#a02f78fba0c2d1f8930ae89d58cfba4c4" title="Identifies a contiguous, adjacent group of four audio channels.">NTV2Audio4ChannelSelect</a>) for output or input.</li>
</ul>
</li>
</ul>
<p><b>Monitor Output:</b> For devices that support analog audio monitoring through two RCA jacks on a breakout box (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a9a858e438a83f5a934afa2c482013599">NTV2DeviceHasAudioMonitorRCAJacks</a> and <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a65a3b8207806dc5f4f54c5b011489c9d">NTV2DeviceCanDoBreakoutBox</a>) and/or a headphone jack (see <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a694d791c7d90e8b4e207bbe31c0045ae">NTV2DeviceHasHeadphoneJack</a>), by default, the monitor output will carry audio channels 1 &amp; 2 (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#a3a847dd1ee3bbe9b15985a9706b6a483a0900586e5d0a2fa78be4f645f56086ea" title="This selects audio channels 1 and 2 (Group 1 channels 1 and 2)">NTV2_AudioChannel1_2</a>) from <b>Audio Sytem 1</b> (<a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516aa7306a07c062c3733dcc53b3b5e898d0" title="This identifies the first Audio System.">NTV2_AUDIOSYSTEM_1</a>).</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a9152d1fa49a2d064f9001cedae360734" title="Answers with the current audio monitor source. The audio output monitor is typically a pair of RCA ja...">CNTV2Card::GetAudioOutputMonitorSource</a> to determine which <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a3a847dd1ee3bbe9b15985a9706b6a483" title="Identifies a pair of audio channels.">NTV2AudioChannelPair</a> and <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> is currently providing samples to the audio monitor output.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ab20517c49125b2c1f50ee2f97dabfaf6" title="Sets the audio monitor output source to a specified audio system and channel pair....">CNTV2Card::SetAudioOutputMonitorSource</a> to change which <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a3a847dd1ee3bbe9b15985a9706b6a483" title="Identifies a pair of audio channels.">NTV2AudioChannelPair</a> and <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> will provide samples to the audio monitor output.</li>
</ul>
<p><b>Non-PCM Data:</b><br  />
</p>
<p>Downstream equipment can be told that the outgoing audio is not carrying PCM data, by setting the non-PCM indicator in the AES header. Older AJA devices can only do this on an audio-system-wide basis — i.e., all outgoing audio groups are marked PCM or non-PCM. Use the simpler form of the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a441f47078eed54df0b09e221884a4a7c" title="Determines whether or not all outgoing audio channel pairs are to be flagged as non-PCM for the given...">CNTV2Card::SetAudioPCMControl</a> function for these devices.</p>
<p>Newer AJA devices can mark individual audio channel pairs as non-PCM (the <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a0e34768434bc20d564f90970c8cc91ae">NTV2DeviceCanDoPCMControl</a> function returns true for devices that support this capability). Use one of the overloaded versions of <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a441f47078eed54df0b09e221884a4a7c" title="Determines whether or not all outgoing audio channel pairs are to be flagged as non-PCM for the given...">CNTV2Card::SetAudioPCMControl</a> that accepts either a single <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a3a847dd1ee3bbe9b15985a9706b6a483" title="Identifies a pair of audio channels.">NTV2AudioChannelPair</a> or an <a class="el" href="../../df/d4b/ntv2card_8h.html#aa5537a3da6785c64c160b4f3c7c65e6f" title="A set of distinct NTV2AudioChannelPair values.">NTV2AudioChannelPairs</a> set.</p>
<p><b>AES Sync-Mode Bit:</b><br  />
</p>
<p>By default, the embedder clears the <b>Sync Mode bit</b> in the <b>AES header</b> in the <b>Audio Control Packet</b>s, which tells downstream equipment that the outgoing audio is <b>asynchronous</b>, even though overall, the correct total number of audio samples over a span of several frames always get transmitted. This is particularly relevant for 29.97/59.94 frame rates, in which the number of 48 kHz audio samples varies with each frame … yet is constant/fixed over a 5-frame sequence.</p>
<p>If downstream equipment expects <b>synchronous</b> audio, and is alarming about the <b>asynchronous</b> audio, the output embedder can be told to set the <b>Sync Mode bit</b>, but note that this is “fibbing”:</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a341078141cf07349ee40e4525147e47a" title="Answers with the current state of the AES Sync Mode bit for the given Audio System&#39;s output.">CNTV2Card::GetAudioOutputAESSyncModeBit</a> to see if the device is setting the Sync Mode bit.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7e0f8e570caad056a4122d574a6a0de7" title="Sets or clears the AES Sync Mode bit for the given Audio System&#39;s output.">CNTV2Card::SetAudioOutputAESSyncModeBit</a> to change the setting.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>When the embedder is configured to “fib” — i.e. set the <b>Sync Mode bit</b> in the <b>AES header</b> in the <b>Audio Control Packet</b> — audio and video are synchronized in time, but the resulting audio doesn’t exactly follow the definition of “synchronized” in SMPTE 299 § 7.2.1.3, because the embedder doesn’t set the <b>Frame Sequence Number</b> in the <b>AES header</b>. SMPTE 299, however, stipulates that receivers should correctly receive audio even from equipment that doesn’t fully conform to § 7.2.1.3.</dd></dl>
<p>The <a class="el" href="../../db/d02/toolsandutilities.html#usingntv2watcher">“NTV2Watcher”</a> tool has a <a class="el" href="../../db/d02/toolsandutilities.html#tonegenerator">“Tone Generator” Tool</a> that can be used to fill any Audio System’s output buffer, either statically (one-time data fill) or dynamically (continuously).</p>
<hr  size="50px" />
 <h2><a class="anchor" id="audiosamplecount"></a>
Correlating Audio Samples to Video Frames</h2>
<p>Because AJA devices use fixed audio sample rates (i.e. 48000 samples per second), some video frame rates will necessarily result in some frames having more audio samples than others. For example, the NTSC frame rate is exactly 30000/1001 frames per second — so by converting frames to samples, the expected number of audio samples at any given frame time can be calculated. This is what the <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#a3e8f64237908a9fd196e71af52754ffb" title="Returns the number of audio samples for a given video frame rate, audio sample rate,...">GetAudioSamplesPerFrame</a> utility function is for: </p><div class="fragment"><div class="line"><span class="comment">//  Print the audio sample count cadence for NTSC 2997...</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a> frame(0);  frame &lt; 60;  )</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#a7d396819a750a83ecd7c2e7f8f4898ec">DEC</a>(::<a class="code" href="../../d0/d81/ntv2utils_8h.html#a63e7a951f4cd53108381106ea576d2f3">GetAudioSamplesPerFrame</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#ad5d23b1875f7b840e92723d7841995fda642f7753b8e1703cfdfb869423341310">NTV2_FRAMERATE_2997</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7100bd510ea6161e94c7b243d05be9afa8b7941481ba79ca2860a71d00631a5f8">NTV2_AUDIO_48K</a>, frame));</div>
<div class="line">    <span class="keywordflow">if</span> (++frame &lt; 60)</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!(frame % 5))</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Capture</b><ul>
<li><b>Without AutoCirculate</b> — the number of audio samples to associate with the current frame is provided by the hardware’s <b>Record Head</b>. Just compare its new position with its old position from the previous frame.</li>
<li><b>With AutoCirculate</b> — Use the <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#ad5b65a78cb290a12684696c031d72f75">AUTOCIRCULATE_TRANSFER::GetCapturedAudioByteCount</a> function.</li>
</ul>
</li>
<li><b>Playout</b><ul>
<li><b>Without AutoCirculate</b> — <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#a3e8f64237908a9fd196e71af52754ffb" title="Returns the number of audio samples for a given video frame rate, audio sample rate,...">GetAudioSamplesPerFrame</a> will return the <em>recommended</em> number of samples to write for the current frame. It’s important to transfer samples ahead of the <b>Play Head</b> (yet not so far or so many as to overrun it).</li>
<li><b>With AutoCirculate</b> — Use <a class="el" href="../../d6/d9b/ntv2utils_8cpp.html#a3e8f64237908a9fd196e71af52754ffb" title="Returns the number of audio samples for a given video frame rate, audio sample rate,...">GetAudioSamplesPerFrame</a> to calculate the number of audio samples to write for the current frame. Transferring more or fewer samples than this number may impel AutoCirculate to reset the audio.</li>
</ul>
</li>
</ul>
<hr  size="50px" />
 <h2><a class="anchor" id="audiomultilink"></a>
Multi-Link Audio (32, 48, 64 Audio Channels)</h2>
<p>By default, per SMPTE standard, up to 16 independent audio channels are supported by a single 3G SDI signal (except for 2K and 4K formats, which only support up to 8 channels, as previously noted, due to reduced HANC space).</p>
<p>SDK 16.2 introduced the capability of adding an additional bank of 16 audio channels with each additional SDI link of multi-link video input or output:</p><ul>
<li>For dual-link 3G, 6G or 12G configurations, up to 32 audio channels are supported.</li>
<li>For quad-link 3G, 6G or 12G (UHD2/8K) configurations, 32, 48 or 64 audio channels are supported.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This feature requires newer firmware and driver version 16.2 or later.</dd></dl>
<p>Essentially, it gangs together 2 to 4 Audio Systems, and operates the higher-numbered ones as “slaves” by the lowest-numbered one – i.e. the “master” – to record (or play) samples through them all simultaneously.</p>
<p>Each controlled Audio System uses its same 4MB of device memory for buffering audio samples. The driver automatically handles redirecting each link’s samples during the DMA (<a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a>).</p>
<dl class="section note"><dt>Note</dt><dd>This capability currently only works with AutoCirculate channels <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6" title="Specifies channel or Frame Store 1 (or the first item).">NTV2_CHANNEL1</a> or <a class="el" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcead307b257181bc49ad4e5e28f16b1a5c7" title="Specifies channel or Frame Store 3 (or the 3rd item).">NTV2_CHANNEL3</a>.</dd></dl>
<p>To enable and use this feature:</p><ul>
<li>Be sure the device being used has the firmware capability by calling <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a18b714ce1e52323225e1c7f8732be94e">NTV2DeviceCanDoMultiLinkAudio</a>. <div class="fragment"><div class="line"><span class="keywordflow">if</span> (::<a class="code" href="../../d9/dfb/ntv2devicefeatures_8hh.html#a18b714ce1e52323225e1c7f8732be94e">NTV2DeviceCanDoMultiLinkAudio</a>(device.<a class="code" href="../../d0/dbc/class_c_n_t_v2_driver_interface.html#a7e4ebdaf05f325d13582eac32084ee5a">GetDeviceID</a>()))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  Has multi-link audio feature</span></div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>During set-up:<ul>
<li>In the call to <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb" title="Prepares for subsequent AutoCirculate ingest, designating a contiguous block of frame buffers on the ...">CNTV2Card::AutoCirculateInitForInput</a> or <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a669e0e26f156eacbba892e1520489f5c" title="Prepares for subsequent AutoCirculate playout, designating a contiguous block of frame buffers on the...">CNTV2Card::AutoCirculateInitForOutput</a>, bitwise-OR into the <em>inOptionFlags</em> parameter the appropriate <code>AUTOCIRCULATE_WITH_MULTILINK_AUDIO</code> constant(s) for each additional SDI link (and therefore additional bank of 16 audio channels) that are desired.<ul>
<li>For example, in a quad-link (UHD or 4K) configuration, to capture 48 channels of audio from the first three SDI links: <div class="fragment"><div class="line">device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb">AutoCirculateInitForInput</a> (<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>,  7,  NTV2_AUDIOSYSTEM1,</div>
<div class="line">        AUTOCIRCULATE_WITH_AUDIO | <a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#af79ca40592abdaee2a188e8d473bd4de">AUTOCIRCULATE_WITH_MULTILINK_AUDIO1</a> | <a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#af44baef6120d8ba330b7fa1a8f308fcc">AUTOCIRCULATE_WITH_MULTILINK_AUDIO2</a>);</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>For each <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> associated with each SDI link:<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a286d834c8cad877d7e1bde2c3a761bba" title="Sets the audio source for the given NTV2AudioSystem on the device.">CNTV2Card::SetAudioSystemInputSource</a> with <code><a class="el" href="../../d6/d0c/ntv2enums_8h.html#af3ee639c1fe12a18f577d43459557617a3780d9057e0195bb034d0d41c03842fd" title="Obtain audio samples from the audio that&#39;s embedded in the video HANC.">NTV2_AUDIO_EMBEDDED</a></code> and the appropriate <code>NTV2_EMBEDDED_AUDIO_INPUT_VIDEO_n</code>.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a57a1348dd818107d730744c95c109e70" title="Sets the number of audio channels to be concurrently captured or played for a given Audio System on t...">CNTV2Card::SetNumberAudioChannels</a> with the maximum (16).</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0de7bf1c36245669115a897366f5f52b" title="Sets the NTV2AudioRate for the given Audio System.">CNTV2Card::SetAudioRate</a> (normally with <code>NTV2_AUDIO_48K</code>).</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a9d6accfbf2f995aac91d16d16d150829" title="Changes the size of the audio buffer that is used for a given Audio System in the AJA device.">CNTV2Card::SetAudioBufferSize</a> (with <code>NTV2_AUDIO_BUFFER_BIG</code>).</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a393cb3e27e8763bf52926ab1e0e70550" title="Enables or disables NTV2AudioLoopBack mode for the given NTV2AudioSystem.">CNTV2Card::SetAudioLoopBack</a> with <code>NTV2_AUDIO_LOOPBACK_OFF</code>.</li>
</ul>
</li>
<li>The per-frame audio buffer used in <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#a3dd008cac30a4e6f1dcb0d016ba6e1cf" title="Sets my buffers for use in a subsequent call to CNTV2Card::AutoCirculateTransfer.">AUTOCIRCULATE_TRANSFER::SetBuffers</a> or <a class="el" href="../../db/dd9/class_a_u_t_o_c_i_r_c_u_l_a_t_e___t_r_a_n_s_f_e_r.html#adc7e3eb26eb326ffe273b5f3308dcdb6" title="Sets my audio buffer for use in a subsequent call to CNTV2Card::AutoCirculateTransfer.">AUTOCIRCULATE_TRANSFER::SetAudioBuffer</a> should be a multiple of the size of a normal buffer used for a single link with 16-channels. The multiplier should be 2 for dual-link SDI (32 channels), 3 for three links (48 channels), or 4 for quad-link (64 channels).</li>
</ul>
</li>
<li>While running:<ul>
<li>For playback, before <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a> is called, be sure the audio buffer contains all of the audio samples intended for each SDI link in ascending link order in the buffer, with each link’s data matching that shown in <a class="el" href="../../d5/d32/dataformats.html#audfmt-16chan">16-Channel Mode</a>. That is, put the first link’s samples in the host buffer first, followed by the second link’s, and so on, with no gaps between each link’s samples. The 32, 48 or 64 channel samples are not interleaved — only the 16-channel samples are interleaved per-link.</li>
<li>For capture, after <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a487c000317d3bacdef53b1b088d83c4d" title="Transfers all or part of a frame as specified in the given AUTOCIRCULATE_TRANSFER object to/from the ...">CNTV2Card::AutoCirculateTransfer</a> returns, the host audio buffer will have all of the audio samples for each SDI link in ascending order in the buffer, with each link’s data matching that shown in <a class="el" href="../../d5/d32/dataformats.html#audfmt-16chan">16-Channel Mode</a>. That is, the first link’s samples will be in the host buffer first, followed by the second link’s, and so on, with no gaps between each link’s samples. The 32, 48 or 64 channel samples are not interleaved — only the 16-channel samples are interleaved per-link.</li>
</ul>
</li>
<li><p class="startli">Examples — a new <code>&ndash;audioLinks</code> option was added to these <a class="el" href="../../d9/d07/demoapps.html">Demonstration Applications</a> …</p><ul>
<li><a class="el" href="../../d9/d07/demoapps.html#ntv2capture4k">NTV2Capture4K Demo</a></li>
<li><a class="el" href="../../d9/d07/demoapps.html#ntv2player4k">NTV2Player4K Demo</a></li>
<li><a class="el" href="../../d9/d07/demoapps.html#ntv2player8k">NTV2Player8K Demo</a></li>
</ul>
<dl class="bug"><dt><b><a class="el" href="../../de/da5/bug.html#_bug000001">Bug:</a></b></dt><dd>At this time, there is no API to support multi-link audio for low-latency (non-AutoCirculate) applications.</dd></dl>
</li>
</ul>
<hr  size="50px" />
 <h2><a class="anchor" id="audiohidden"></a>
“Hidden” Audio Systems</h2>
<p>Modern AJA devices intended for “retail” markets, particularly newer <a class="el" href="../../d0/d53/ntv2devices.html#ntv2hwkona">Kona Boards</a> and <a class="el" href="../../d0/d53/ntv2devices.html#ntv2hwio">Io (Thunderbolt) Devices</a>, may have firmware that implements additional “hidden” <b>Audio System</b>s that aren’t reported by the <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a22e624db258df962f03a1796e55c5c2b">NTV2DeviceGetNumAudioSystems</a> function:</p><ul>
<li>A <b>Host Audio System</b> for audio input/output to/from the host operating system (see <a class="el" href="../../dd/d86/ntv2devicefeatures_8cpp.html#a738bfb489c95e2de5d0b1a7b7b0cff8e">NTV2DeviceGetHostAudioSystem</a>);</li>
<li>A “phantom” <b>Mixer Audio System</b> that uses only FIFOs (no audio buffer memory) in order to implement an <a class="el" href="../../d1/dc5/ntv2devops.html#audiomixer">Audio Mixer</a> (see <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a77a1aa4059ff98d5ab7b6c6a27975d9e">CNTV2Card::DeviceCanDoAudioMixer</a> and <a class="el" href="../../dd/d86/ntv2devicefeatures_8cpp.html#a3314d50b3deab030752b0ad8613d3878">NTV2DeviceGetAudioMixerSystem</a>).</li>
</ul>
<p>These additional <b>Audio System</b>s help support AJA’s “retail” software (i.e. Adobe, Avid, Apple, Telestream, etc. plug-ins, AJA ControlRoom, etc).</p>
<p>The <b>Host Audio System</b> is used to continuously deliver…</p><ul>
<li>SDI/HDMI/AES audio from the AJA KONA/Io device as input to the host computer’s primary audio system. For example, this would enable an audio capture program running on the host (e.g. Audacity) to capture audio from an SDI input signal on the KONA/Io device.</li>
<li>Host audio output from the host OS’s primary system audio to the KONA/Io device’s SDI/HDMI/AES output. For example, this would enable audio from a web browser running on the host computer to playout through a KONA/Io device’s SDI output.</li>
</ul>
<p>The <b>Host Audio System</b> is started and operated by the AJA kernel driver in conjunction with the host computer system’s audio control panel. It allows host audio to operate independently of other <b>Audio System</b>s on the device that may be used by AutoCirculate or other SDK client software.</p>
<p>Since the <b>host audio system</b> uses audio buffer memory in device SDRAM, it’s susceptible to <a class="el" href="../../d1/dc5/ntv2devops.html#audioclobber">Audio Buffer Corruption</a> if an excessively large video buffer number is used by an active <b>FrameStore</b>.</p>
<hr  size="50px" />
 <h2><a class="anchor" id="audioclobber"></a>
Audio Buffer Corruption</h2>
<p>It’s possible (and quite easy) to configure a <b>FrameStore</b> to write video into audio buffer memory. For example: </p><div class="fragment"><div class="line"><a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a> device;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="../../d2/d67/class_c_n_t_v2_device_scanner.html#a43517c9c7fedc4d199ef7616ce223276">CNTV2DeviceScanner::GetFirstDeviceFromArgument</a>(<span class="stringliteral">&quot;0&quot;</span>, device))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  Assume this device has valid video signal at SDI Input 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a64a4c4087fa84101dba3a59f91c5ab31">ClearRouting</a>();  <span class="comment">//  Clear all existing connections</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">EnableChannel</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>);    <span class="comment">//  Enable FrameStore 1</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033">SetMode</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46">NTV2_MODE_CAPTURE</a>);   <span class="comment">//  Set FrameStore 1 to capture mode</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">SetSDITransmitEnable</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, <span class="keyword">false</span>);  <span class="comment">//  Set SDI connector 1 to capture</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">Connect</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4ac4aee26674a8a4ae84d209468d5333ee">NTV2_XptFrameBuffer1Input</a>, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16aeb92ee9e88c84198ee883600cddaaa02">NTV2_XptSDIIn1</a>);  <span class="comment">//  Connect SDI In 1 to FrameStore 1</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//  Which video frame is the first to contain audio system audio?</span></div>
<div class="line">    <span class="comment">//  You could just start incrementing frame numbers until you start getting bad audio.</span></div>
<div class="line">    <span class="comment">//  But here’s how to really do it...</span></div>
<div class="line">    <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54af">NTV2FrameGeometry</a>       fg;</div>
<div class="line">    <a class="code" href="../../d6/d0c/ntv2enums_8h.html#ace03c7b6e4f21738519430d1fa42161c">NTV2FrameBufferFormat</a>   fbf;</div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a0d9cd9dfba7cb36582da82deef4cb522">GetFrameGeometry</a>(fg, <a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>);</div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#a197831a736299e2c68e3f7f0f860387f">GetFrameBufferFormat</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, fbf);</div>
<div class="line">    <a class="code" href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a> firstAudioFrameNum = <a class="code" href="../../d8/d0f/ntv2devicefeatures_8h.html#a654a5f0b892e2bce1031b258c723095a">::NTV2DeviceGetNumberFrameBuffers</a>(device.<a class="code" href="../../d0/dbc/class_c_n_t_v2_driver_interface.html#a7e4ebdaf05f325d13582eac32084ee5a">GetDeviceID</a>(), fg, fbf);</div>
<div class="line">    <span class="keywordflow">if</span> (::<a class="code" href="../../d9/dfb/ntv2devicefeatures_8hh.html#ae561712c383551002a87e2b13a4d4296">NTV2DeviceCanDoStackedAudio</a>(device.<a class="code" href="../../d0/dbc/class_c_n_t_v2_driver_interface.html#a7e4ebdaf05f325d13582eac32084ee5a">GetDeviceID</a>()))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a>          chan1CtrlBits(0);</div>
<div class="line">        mDevice.ReadRegister(<a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#a44465b2926268ea111cf5d357016baefaedeed12a55d2b240e384a99d57e1cc55">kRegCh1Control</a>, &amp;chan1CtrlBits);</div>
<div class="line">        <a class="code" href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a>          frameSizeMB (1 &lt;&lt; (((chan1CtrlBits &amp; <a class="code" href="../../d4/dd7/ntv2publicinterface_8h.html#ac2cd24508e310b59ed5ab3d0b0bfd999abcaf9fb2675d3698246278f2c22b7a96">kK2RegMaskFrameSize</a>) &gt;&gt; 20) + 1));</div>
<div class="line">        <span class="keywordflow">if</span> (frameSizeMB &lt; 8)</div>
<div class="line">            frameSizeMB = 8;    <span class="comment">//  No 2MB mode!</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a>    maxRamBytes(::<a class="code" href="../../d9/dfb/ntv2devicefeatures_8hh.html#a4c829f30c5602163d455999d7b358eb4">NTV2DeviceGetActiveMemorySize</a>(device.<a class="code" href="../../d0/dbc/class_c_n_t_v2_driver_interface.html#a7e4ebdaf05f325d13582eac32084ee5a">GetDeviceID</a>()));</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a>    numAudioSystems(::<a class="code" href="../../d9/dfb/ntv2devicefeatures_8hh.html#a22e624db258df962f03a1796e55c5c2b">NTV2DeviceGetNumAudioSystems</a>(device.<a class="code" href="../../d0/dbc/class_c_n_t_v2_driver_interface.html#a7e4ebdaf05f325d13582eac32084ee5a">GetDeviceID</a>()));</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a>    totalAudioBytes(numAudioSystems * 8ULL*1024ULL*1024*ULL);   <span class="comment">//  8MB per audio system</span></div>
<div class="line">        firstAudioFrameNum = (maxRamBytes - totalAudioBytes) / frameSizeMB;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//  UH-OH:  This will cause video to be written into the audio buffers...</span></div>
<div class="line">    device.<a class="code" href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11">SetInputFrame</a>(<a class="code" href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a>, firstAudioFrameNum);    <span class="comment">//  Write FrameStore 1 video into audio area</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In the above example…</p><ul>
<li>On “stacked audio” devices, this will write video into the last <b>Audio System</b>’s buffer memory.</li>
<li>On older “non-stacked audio” devices, this will write video into the first <b>Audio System</b>’s buffer memory.</li>
<li>To notice the corruption, the affected <b>Audio System</b> will need to be running (playout and/or capture).</li>
<li>It’s more likely to be noticed in audio playout, since the output audio buffer starts at the top of the frame.</li>
<li>Small frame geometries and pixel formats (e.g., 8-bit YUV 525i) are less likely to touch the audio capture buffer that starts 4MB into the frame.</li>
</ul>
<p>It’s also possible (and quite easy) to configure a <b>FrameStore</b> to playout SDI/HDMI video that’s been corrupted by audio-in-the-video. This would happen if the <b>FrameStore</b> is set for playout and it’s using a frame buffer that’s also being used by a running <b>Audio System</b>.</p>
<hr  size="50px" />
 <h2><a class="anchor" id="audiomixer"></a>
Audio Mixer</h2>
<p>Some newer NTV2 devices have firmware that implements a three-multichannel-input <b>Audio Mixer</b>.</p><ul>
<li>To determine if a device supports this feature, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#a79ac1a76778b95a3f27e70f004391b28">NTV2DeviceCanDoAudioMixer</a>.</li>
<li>To determine if the device actually has this feature in its running firmware, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a77a1aa4059ff98d5ab7b6c6a27975d9e">CNTV2Card::DeviceCanDoAudioMixer</a>.</li>
<li>To determine the <a class="el" href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516" title="Used to identify an Audio System on an NTV2 device. See Audio System Operation for more information.">NTV2AudioSystem</a> of the mixer, call <a class="el" href="../../dd/d86/ntv2devicefeatures_8cpp.html#a3314d50b3deab030752b0ad8613d3878">NTV2DeviceGetAudioMixerSystem</a>.</li>
</ul>
<p>The <b>Audio Mixer</b> firmware supports up to three two-channel (stereo) audio inputs:</p><ul>
<li><b>Main</b> — can utilize any audio channel pair from any <b>Audio System</b>:</li>
<li><b>Auxiliary 1</b> — the first two audio channels from any <b>Audio System</b>:</li>
<li><b>Auxiliary 2</b> — the first two audio channels from any <b>Audio System</b>:</li>
<li>To discover which <b>Audio System</b>’s output is feeding any given mixer input, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a15f99c77a6c9aaf3b6c957e7b997db0e" title="Answers with the Audio System that&#39;s currently driving the given input of the Audio Mixer.">CNTV2Card::GetAudioMixerInputAudioSystem</a>. To change it, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a6d82f552fd3a25ae471a118163a27cd4" title="Sets the Audio System that will drive the given input of the Audio Mixer.">CNTV2Card::SetAudioMixerInputAudioSystem</a>.</li>
<li>To discover which audio channel pair is currently feeding any given mixer input, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aa8d2d491b5f8d050db8531503ed2f7b1" title="Answers with the Audio Channel Pair that&#39;s currently driving the given input of the Audio Mixer.">CNTV2Card::GetAudioMixerInputChannelSelect</a>. To change it, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a8a488564443b1d61be1640deac78bf6f" title="Specifies the Audio Channel Pair that will drive the given input of the Audio Mixer.">CNTV2Card::SetAudioMixerInputChannelSelect</a>.</li>
</ul>
<p>The resulting mixed audio is inserted onto the audio channel pair selected for the mix from the Main input, and the rest of that <b>Audio System</b>’s channel pairs are passed through to that same <b>Audio System</b>’s output (unless they’ve been muted).</p>
<p>Any of the <b>Audio Mixer</b>’s inputs can be disabled (muted) or enabled (unmuted).</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ace1b7114862bc8259c0432a295316d7b" title="Answers with a std::bitset that indicates which input audio channels of the given Audio Mixer input a...">CNTV2Card::GetAudioMixerInputChannelsMute</a> to determine which audio channels of an <b>Audio Mixer</b>’s input are enabled or muted.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ac2cca30edcdcaf110ab3942fbbba56b9" title="Mutes (or enables) the given output audio channel of the Audio Mixer.">CNTV2Card::SetAudioMixerInputChannelsMute</a> to change them.</li>
</ul>
<p>Each <b>Audio Mixer</b> input has a gain control.</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7dc370c2b27c9ffa3823a4b8a3a6ca78" title="Answers with the current gain setting for the Audio Mixer&#39;s given input.">CNTV2Card::GetAudioMixerInputGain</a> to determine an input’s current gain setting.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a170395abcc495c36f4ade89a319f0a86" title="Sets the gain for the given input of the Audio Mixer.">CNTV2Card::SetAudioMixerInputGain</a> to change the setting.</li>
</ul>
<p>Each audio channel of the <b>Audio Mixer</b>’s output (up to 16 channels) can be individually muted.</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a518564eba6c857d18016f8b49af0154a" title="Answers with a std::bitset that indicates which output audio channels of the Audio Mixer are currentl...">CNTV2Card::GetAudioMixerOutputChannelsMute</a> to discover which mixer output audio channels are muted/disabled, and which are enabled/unmuted.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a53acd46af6a39841c381fc6da564f8dd" title="Mutes or enables the individual output audio channels of the Audio Mixer.">CNTV2Card::SetAudioMixerOutputChannelsMute</a> to mute or unmute the output audio channels.</li>
</ul>
<p>The <b>Audio Mixer</b>’s audio levels can be monitored:</p><ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a51ffbf584ba447aaa4a93e83ddb4290c" title="Answers with the Audio Mixer&#39;s current audio input levels.">CNTV2Card::GetAudioMixerInputLevels</a> to get the current levels of any specific audio channels of an input.</li>
<li>The sample count the firmware uses for calculating audio levels is configurable:<ul>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aef1854e2e8fe9abd181838e9c041da04" title="Answers with the Audio Mixer&#39;s current sample count used for measuring audio levels.">CNTV2Card::GetAudioMixerLevelsSampleCount</a> to get the current sample count in use.</li>
<li>Call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ae3f56e432f6e2284c8c4c67b848b5476" title="Sets the Audio Mixer&#39;s sample count it uses for measuring audio levels.">CNTV2Card::SetAudioMixerLevelsSampleCount</a> to change the setting.</li>
</ul>
</li>
</ul>
<hr  size="50px" />
 <h1><a class="anchor" id="devicefirmware"></a>
Firmware</h1>
<p>NTV2 devices have an EEPROM (non-volatile memory) that stores its FPGA programming. This flash memory is commonly divided into a minimum of two logical partitions:</p><ul>
<li>the “main” partition — for the normal FPGA bitfile image;</li>
<li>the “failsafe” boot — for a fallback FPGA bitfile image.</li>
</ul>
<p>Some AJA devices — like the <a class="el" href="../../d0/d53/ntv2devices.html#konaip">KONA IP</a> — have, in addition to the normal FPGA hardware, a microprocessor, which requires an additional, separate firmware bitfile that bootstraps and operates it. This extra firmware is bundled into a “package” that is also stored in (and loaded from) a separate partition in the EEPROM.</p>
<p>Traditionally, the FPGA is only loaded from flash memory upon power-up. The “failsafe” bitfile loads if…</p><ul>
<li>the board’s “failsafe” button is held down while power is applied to the board;</li>
<li>the “main” FPGA bitfile image was invalid or otherwise failed to load.</li>
</ul>
<p>All NTV2 devices have two on-board LEDs that indicate readiness:</p><ol type="1">
<li><b>Power</b> — If the board has power, this will indicate <b>Green</b>; otherwise it won’t be lit.</li>
<li><b>FPGA Load State:</b><ul>
<li><b>Green</b> — Normal firmware bitfile loaded successfully.</li>
<li><b>Amber</b> — Fail-safe firmware bitfile loaded.</li>
<li><b>Red</b> — FPGA not programmed; firmware load failed.</li>
</ul>
</li>
</ol>
<p>When operating normally, both LEDs will be <b>Green</b>.</p>
<dl class="section note"><dt>Note</dt><dd>On the Io and T-Tap products, the LEDs are hidden inside the chassis and can’t be seen.</dd></dl>
<hr  size="50px" />
 <h2><a class="anchor" id="dev-firmware-loading"></a>
Loading Firmware</h2>
<p>Loading the FPGA from EEPROM after power-up takes a finite amount of time. If this exceeds the amount of time allotted by the BIOS for PCIe devices to become ready, the AJA device won’t be detected by the BIOS, and thus won’t be probed by — or matched to — any device drivers.</p><ul>
<li>On Windows PCs, this is shown as an “<em>Unknown device</em>” in the Windows <b>Device Manager</b>.</li>
<li>On Linux PCs, the ‘<b>lspci</b>’ command can help diagnose these issues. For example, here’s what ‘<b>lspci</b>’ should normally show when looking for devices with AJA’s PCIe vendor ID of <code>0xF1D0</code> (e.g. for a Corvid88): <div class="fragment"><div class="line">$ lspci -d f1d0:</div>
<div class="line">03:00.0 Multimedia video controller: AJA Video Device eb0d</div>
<div class="line">$ lspci -n  -d f1d0:</div>
<div class="line">03:00.0 0400: f1d0:eb0d</div>
<div class="line">$ lspci -nn  -d f1d0:</div>
<div class="line">03:00.0 Multimedia video controller [0400]: AJA Video Device [f1d0:eb0d]</div>
</div><!-- fragment --></li>
</ul>
<p><b>Disable Fast-Boot Option:</b><br  />
 On PCs running Windows or Linux, be sure to disable all fast-boot options in the BIOS.</p>
<p><b>Disable Power-Saving Modes:</b><br  />
 AJA’s NTV2 devices do not support PCIe power management.</p><ul>
<li>Be sure to disable any and all Energy-Saving features in the OS, particularly PCIe “Link State Power Management” (LSPM).</li>
<li><b>Windows</b> — This is in “Advanced Power Settings” ==≻ “Power Options” ==≻ “PCI Express” ==≻ “Link State Power Management” ==≻ <b>Off</b>.</li>
<li><b>Linux</b> — Use the <code>lspci</code> command: <div class="fragment"><div class="line">$ sudo lspci -vvv  -d f1d0:</div>
</div><!-- fragment --> … and confirm that “LnkCtl: ASPM Disabled” is shown for each AJA device.</li>
<li>On some motherboards, power management is controlled by the BIOS, in which case, try <b>disabling ASPM</b> under the BIOS’ <b>power options</b>.</li>
</ul>
<p>If, even after disabling “fast-boot”, the AJA device fails to show up, …</p><ul>
<li>Try “warm-booting” the PC. If the device is recognized after a warm-boot, then it’s likely a firmware load-time issue.</li>
<li>Try installing the AJA board into a different PCIe slot on the motherboard. Some manufacturers employ chips that perform intermediate buffering on certain specific PCIe slots that can sometimes cause detection issues. Also beware that some manufacturers use a custom BIOS that has options for configuring PCIe slots, so be sure to check those BIOS settings and adjust them if needed.</li>
<li>If the device still fails to show up, please <a href="https://sdksupport.aja.com/index.php?/Tickets/Submit">submit a Ticket</a>.</li>
</ul>
<p><b>“Warm Boot” Reload</b><br  />
 Some newer AJA devices are capable of reloading the FPGA upon a <b>PCIe Reset</b> — aka a “warm boot”.</p><ul>
<li>To test if the device can do a “warm boot” FPGA reload, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a601943e16f5416b835ba6d7bd39709a1" title="Answers whether or not the FPGA can be reloaded without powering off.">CNTV2Card::CanWarmBootFPGA</a>.</li>
<li>Note that AJA devices with Thunderbolt ports (e.g. <a class="el" href="../../d0/d53/ntv2devices.html#io4kplus">Io4K Plus</a> ), or AJA boards installed on Thunderbolt PCIe card-cages receive a <b>PCIe Reset</b> when the Thunderbolt cable is unplugged and subsequently reconnected.</li>
</ul>
<hr  size="50px" />
 <h2><a class="anchor" id="dev-firmware-flash"></a>
“Flashing” Firmware</h2>
<p>AJA provides two ways to “flash” — i.e. update — new firmware into the device’s EEPROM storage:</p><ol type="1">
<li>Using the <a href="https://sdksupport.aja.com/index.php?/Knowledgebase/Article/View/129">ntv2firmwareinstaller</a> command-line utility, described in <a class="el" href="../../db/d02/toolsandutilities.html">Tools and Utilities</a>.</li>
<li>Using the <b>AJA ControlPanel</b>, which is part of the “retail” software that can be downloaded from <a href="https://www.aja.com/">https://www.aja.com/</a>.</li>
</ol>
<p>Once the new firmware has been written into the device EEPROM storage, it won’t “run” until the device FPGA gets reloaded (see <a class="el" href="../../d1/dc5/ntv2devops.html#dev-firmware-loading">Loading Firmware</a> above).</p>
<hr  size="50px" />
 <h2><a class="anchor" id="dev-firmware-vers"></a>
Determining Firmware Version</h2>
<dl class="section note"><dt>Note</dt><dd>The <b>currently-running firmware</b> could be different from the <b>currently-installed firmware</b> that’s stored in the EEPROM’s main partition. This can happen if the device wasn’t power-cycled after a firmware update installation, or if the device was booted using its “failsafe” firmware.</dd></dl>
<p>There are three ways to determine what firmware is installed, and/or which firmware is running on an AJA device:</p><ul>
<li>the <a href="https://sdksupport.aja.com/index.php?/Knowledgebase/Article/View/129">ntv2firmwareinstaller</a> command line utility, using its <b>&ndash;info</b> option;</li>
<li>the “Info” or “Firmware” panels of the <b>AJA ControlPanel</b> application (in AJA’s “retail” software);</li>
<li>programmatically using certain SDK API calls (described below).</li>
</ul>
<p>Newer AJA devices (starting with the <a class="el" href="../../d0/d53/ntv2devices.html#corvid88">Corvid 88</a>) report their <b>currently-running firmware date</b> in register 88, which is made available as numeric date components or a <code>std::string</code> by calling <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a793ddcf534365ffcb567f762ac50ab09" title="Reports the (local Pacific) build date of the currently-running firmware.">CNTV2Card::GetRunningFirmwareDate</a>.</p>
<p>Older AJA devices prior to the introduction of the <a class="el" href="../../d0/d53/ntv2devices.html#corvid88">Corvid 88</a> have no way of reporting their <b>currently-running firmware date</b> — they can only report the running firmware’s <em>revision number</em> (which was stored in a portion of register 48 and made available by the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ad96e076b71c75d40838f708036c958f0" title="Reports the revision number of the currently-running firmware.">CNTV2Card::GetRunningFirmwareRevision</a> function. To correlate the revision number to a date, it must be looked up on the device’s firmware page on the <a href="https://sdksupport.aja.com/index.php?/Knowledgebase/List/Index/25/ntv2-firmware">AJA SDK support site’s KnowledgeBase</a> (not very convenient).</p>
<ul>
<li>To determine if a device is capable of reporting its <b>currently-running firmware date</b>, call <a class="el" href="../../dd/d0f/ntv2devicefeatures_8hpp.html#ad99a064214045db13f7f6dfc1aa1cc3d">NTV2DeviceCanReportRunningFirmwareDate</a>.</li>
<li>To determine the <b>currently-installed firmware</b> date, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a3543fcef1614c5178b663c62720675f8" title="Returns the size and time/date stamp of the device&#39;s currently-installed firmware.">CNTV2Card::GetInstalledBitfileInfo</a>.</li>
<li>To test if the fail-safe firmware is currently loaded, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7a7c6e67da9848dde7856c6279636e37" title="Answers whether or not the &quot;fail-safe&quot; (aka &quot;safe-boot&quot;) bitfile is currently loaded and running in t...">CNTV2Card::IsFailSafeBitfileLoaded</a>.</li>
</ul>
<hr  size="50px" />
 <h2><a class="anchor" id="dev-firmware-features"></a>
Determining Firmware Features</h2>
<p>NTV2, being an old and rather crude architecture, has no automatically-enforced linkage between the firmware and the SDK — i.e. the SDK is neither generated from the firmware, nor is the firmware generated from the SDK. Thus, the SDK cannot simply “query the board” to find out how many of a particular widget a device’s running firmware implements, or if a new widget or feature is present (by simply reading registers). Unfortunately, this puts the burden of feature inquiry entirely into software, and onto the authors of NTV2 client applications.</p>
<p>The <a class="el" href="../../d7/dce/ajantv2.html#libajantv2-devicefeatures">Device Features API</a> functions cover 95% of all hardware and firmware feature variations on all NTV2 devices. There are, however, a few features that can only be determined by querying the running device itself. Here are two examples:</p><ul>
<li>The <a class="el" href="../../d0/d53/ntv2devices.html#io4kplus">Io4K Plus</a> and <a href="https://www.avid.com/products/avid-artist-io/features#Avid-Artist-DNxIV">Avid DNxIV</a> use identical firmware, but only the Avid device has an XLR microphone input on its front panel. Thus, <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7e80190935ed4b3c386e6e8b85c6b1ca">CNTV2Card::DeviceHasMicInput</a> is the only way to differentiate between the two devices.</li>
<li>CNTV2Card::HasCanConnectROM is the only way to tell if a given firmware has the ROM feature used by <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#aa73aab628edc804ae9bcd91637dc8a2f" title="Answers whether or not the given widget signal input (sink) can legally be connected to the given sig...">CNTV2Card::CanConnect</a> to determine if a given connection is actually implemented in the firmware.</li>
</ul>
<p>AJA will do its best to ensure that the “NTV2DeviceCanDo…”, “NTV2DeviceHas…” and “NTV2DeviceGetNum…” functions are correct for the specific set of firmware bitfiles that have been qualified for a given SDK release. The release notes on the SDK download page will point out any firmware features added (or removed).</p>
<hr  size="50px" />
 <h2><a class="anchor" id="dev-bitfile-switching"></a>
Fast Bitfile Switching</h2>
<p>New 8K and 12-bit workflows have made it extremely difficult to simultaneously fit FrameStores, CSCs, LUTs, and Mixers into even the much larger modern FPGAs. This has made it necessary to enable the ability to rapidly switch between different workflow-based bitfiles.</p>
<p>There’s a new API in the <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html" title="I interrogate and control an AJA video/audio capture/playout device.">CNTV2Card</a> class that adds support for this capability:</p><ul>
<li>To determine if the device supports fast dynamic loading of bitfiles, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a42311b8ba95ebdd2f358f13a4f635274">CNTV2Card::IsDynamicDevice</a>.</li>
<li>To determine what device IDs are available for fast dynamic loading on the current device, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a0e208d4221cfcb5ff0f83e818affdfba">CNTV2Card::GetDynamicDeviceIDs</a>.</li>
<li>To determine if a particular <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aaa90748f5a92082fa4f79c89698d9463" title="Identifies a specific AJA NTV2 device model number. The NTV2DeviceID is actually the PROM part number...">NTV2DeviceID</a> can be loaded on the current device, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#ae3570f87f8e84d1105cdebaae62b8b5c">CNTV2Card::CanLoadDynamicDevice</a>.</li>
<li>To quickly and dynamically load a specific <a class="el" href="../../d6/d0c/ntv2enums_8h.html#aaa90748f5a92082fa4f79c89698d9463" title="Identifies a specific AJA NTV2 device model number. The NTV2DeviceID is actually the PROM part number...">NTV2DeviceID</a> bitfile onto the current device, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a2e72e197a38ab3eecd0b9b8143d6443b" title="Quickly, dynamically loads the given device ID firmware.">CNTV2Card::LoadDynamicDevice</a>.</li>
<li>To add a specific bitfile to the cache of known bitfiles, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a16165db8e3f5ff06ba91cd7803775f75" title="Adds the given bitfile to the list of available dynamic bitfiles.">CNTV2Card::AddDynamicBitfile</a>.</li>
<li>To add multiple bitfiles inside a host file directory (folder) to the cache of known bitfiles, call <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html#a7c42f6420519743011a7a1fc03f30a1b" title="Adds all bitfiles found in the given host file directory to the list of available dynamic bitfiles.">CNTV2Card::AddDynamicDirectory</a>.</li>
</ul>
<p>These new API calls make use of a new <a class="el" href="../../dc/db5/class_c_n_t_v2_bitfile_manager.html" title="I manage and cache any number of bitfiles for any number of NTV2 devices/designs.">CNTV2BitfileManager</a> singleton class that caches and manages the available bitfiles for various AJA devices. It can be used if finer control is needed over the basic functionality in <a class="el" href="../../d7/dfb/class_c_n_t_v2_card.html" title="I interrogate and control an AJA video/audio capture/playout device.">CNTV2Card</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="antv2enums_8h_html_a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcea771f9f386b8b1bdffd3b2171e723ff40">NTV2_CHANNEL2</a></div><div class="ttdeci">@ NTV2_CHANNEL2</div><div class="ttdoc">Specifies channel or Frame Store 2 (or the 2nd item).</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01308">ntv2enums.h:1308</a></div></div>
<div class="ttc" id="antv2enums_8h_html_ad5d23b1875f7b840e92723d7841995fda642f7753b8e1703cfdfb869423341310"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#ad5d23b1875f7b840e92723d7841995fda642f7753b8e1703cfdfb869423341310">NTV2_FRAMERATE_2997</a></div><div class="ttdeci">@ NTV2_FRAMERATE_2997</div><div class="ttdoc">Fractional rate of 30,000 frames per 1,001 seconds.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l00403">ntv2enums.h:403</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a7100bd510ea6161e94c7b243d05be9afa8b7941481ba79ca2860a71d00631a5f8"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a7100bd510ea6161e94c7b243d05be9afa8b7941481ba79ca2860a71d00631a5f8">NTV2_AUDIO_48K</a></div><div class="ttdeci">@ NTV2_AUDIO_48K</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01875">ntv2enums.h:1875</a></div></div>
<div class="ttc" id="antv2devicefeatures_8hh_html_a4c829f30c5602163d455999d7b358eb4"><div class="ttname"><a href="../../d9/dfb/ntv2devicefeatures_8hh.html#a4c829f30c5602163d455999d7b358eb4">NTV2DeviceGetActiveMemorySize</a></div><div class="ttdeci">ULWord NTV2DeviceGetActiveMemorySize(const NTV2DeviceID inDeviceID)</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d0f/ntv2devicefeatures_8hpp_source.html#l08262">ntv2devicefeatures.hpp:8262</a></div></div>
<div class="ttc" id="antv2devicefeatures_8hh_html_a18b714ce1e52323225e1c7f8732be94e"><div class="ttname"><a href="../../d9/dfb/ntv2devicefeatures_8hh.html#a18b714ce1e52323225e1c7f8732be94e">NTV2DeviceCanDoMultiLinkAudio</a></div><div class="ttdeci">bool NTV2DeviceCanDoMultiLinkAudio(const NTV2DeviceID inDeviceID)</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d0f/ntv2devicefeatures_8hpp_source.html#l04155">ntv2devicefeatures.hpp:4155</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_device_scanner_html_a43517c9c7fedc4d199ef7616ce223276"><div class="ttname"><a href="../../d2/d67/class_c_n_t_v2_device_scanner.html#a43517c9c7fedc4d199ef7616ce223276">CNTV2DeviceScanner::GetFirstDeviceFromArgument</a></div><div class="ttdeci">static bool GetFirstDeviceFromArgument(const std::string &amp;inArgument, CNTV2Card &amp;outDevice)</div><div class="ttdoc">Rescans the host, and returns an open CNTV2Card instance for the AJA device that matches a command li...</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/db4/ntv2devicescanner_8cpp_source.html#l00327">ntv2devicescanner.cpp:327</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a64a4c4087fa84101dba3a59f91c5ab31"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a64a4c4087fa84101dba3a59f91c5ab31">CNTV2Card::ClearRouting</a></div><div class="ttdeci">virtual bool ClearRouting(void)</div><div class="ttdoc">Removes all existing signal path connections between any and all widgets on the AJA device.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d99/ntv2regroute_8cpp_source.html#l00278">ntv2regroute.cpp:278</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_aacca5b4dbd0ba69c049087aa2caf6fcb"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#aacca5b4dbd0ba69c049087aa2caf6fcb">CNTV2Card::AutoCirculateInitForInput</a></div><div class="ttdeci">virtual bool AutoCirculateInitForInput(const NTV2Channel inChannel, const UWord inFrameCount=7, const NTV2AudioSystem inAudioSystem=NTV2_AUDIOSYSTEM_INVALID, const ULWord inOptionFlags=0, const UByte inNumChannels=1, const UWord inStartFrameNumber=0, const UWord inEndFrameNumber=0)</div><div class="ttdoc">Prepares for subsequent AutoCirculate ingest, designating a contiguous block of frame buffers on the ...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/dc3/ntv2autocirculate_8cpp_source.html#l00221">ntv2autocirculate.cpp:221</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a1f528a34e2c5a5b481b846434396a784"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a1f528a34e2c5a5b481b846434396a784">CNTV2Card::SetOutputFrame</a></div><div class="ttdeci">virtual bool SetOutputFrame(const NTV2Channel inChannel, const ULWord inValue)</div><div class="ttdoc">Sets the output frame index number for the given FrameStore. This identifies which frame in device SD...</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l02207">ntv2register.cpp:2207</a></div></div>
<div class="ttc" id="antv2enums_8h_html_ace03c7b6e4f21738519430d1fa42161c"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#ace03c7b6e4f21738519430d1fa42161c">NTV2FrameBufferFormat</a></div><div class="ttdeci">NTV2FrameBufferFormat</div><div class="ttdoc">Identifies a particular video frame buffer format. See Device Frame Buffer Formats for details.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l00207">ntv2enums.h:207</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dceac8b886b1339c52f100305aefff5298c6">NTV2_CHANNEL1</a></div><div class="ttdeci">@ NTV2_CHANNEL1</div><div class="ttdoc">Specifies channel or Frame Store 1 (or the first item).</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01307">ntv2enums.h:1307</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a5c96925ccda0a4b57c5bf352d648c1fe"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a5c96925ccda0a4b57c5bf352d648c1fe">CNTV2Card::SetSDITransmitEnable</a></div><div class="ttdeci">virtual bool SetSDITransmitEnable(const NTV2Channel inChannel, const bool inEnable)</div><div class="ttdoc">Sets the specified bidirectional SDI connector to act as an input or an output.</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l03805">ntv2register.cpp:3805</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a197831a736299e2c68e3f7f0f860387f"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a197831a736299e2c68e3f7f0f860387f">CNTV2Card::GetFrameBufferFormat</a></div><div class="ttdeci">virtual bool GetFrameBufferFormat(NTV2Channel inChannel, NTV2FrameBufferFormat &amp;outValue)</div><div class="ttdoc">Returns the current frame buffer format for the given FrameStore on the AJA device.</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l01891">ntv2register.cpp:1891</a></div></div>
<div class="ttc" id="antv2publicinterface_8h_html_af79ca40592abdaee2a188e8d473bd4de"><div class="ttname"><a href="../../d4/dd7/ntv2publicinterface_8h.html#af79ca40592abdaee2a188e8d473bd4de">AUTOCIRCULATE_WITH_MULTILINK_AUDIO1</a></div><div class="ttdeci">#define AUTOCIRCULATE_WITH_MULTILINK_AUDIO1</div><div class="ttdoc">Use this to AutoCirculate with base audiosystem controlling base AudioSystem + 1.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dd7/ntv2publicinterface_8h_source.html#l05500">ntv2publicinterface.h:5500</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a8c757863040a131ff5aa4e0e93284fd4ac4aee26674a8a4ae84d209468d5333ee"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4ac4aee26674a8a4ae84d209468d5333ee">NTV2_XptFrameBuffer1Input</a></div><div class="ttdeci">@ NTV2_XptFrameBuffer1Input</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l02688">ntv2enums.h:2688</a></div></div>
<div class="ttc" id="aajatypes_8h_html_ad3e6ac24329134f5b4c9993f13328db2"><div class="ttname"><a href="../../db/de2/ajatypes_8h.html#ad3e6ac24329134f5b4c9993f13328db2">ULWord</a></div><div class="ttdeci">uint32_t ULWord</div><div class="ttdef"><b>Definition:</b> <a href="../../db/de2/ajatypes_8h_source.html#l00246">ajatypes.h:246</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_af7ba7fb1976e09942caeb89219a396f8"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#af7ba7fb1976e09942caeb89219a396f8">CNTV2Card::SetReference</a></div><div class="ttdeci">virtual bool SetReference(const NTV2ReferenceSource inRefSource, const bool inKeepFramePulseSelect=false)</div><div class="ttdoc">Sets the device's clock reference source. See Device Clocking and Synchronization for more informatio...</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l01486">ntv2register.cpp:1486</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_afa402ad4a3bb265d450505c1a431f3e1"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#afa402ad4a3bb265d450505c1a431f3e1">CNTV2Card::Connect</a></div><div class="ttdeci">virtual bool Connect(const NTV2InputCrosspointID inInputXpt, const NTV2OutputCrosspointID inOutputXpt, const bool inValidate=false)</div><div class="ttdoc">Connects the given widget signal input (sink) to the given widget signal output (source).</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d99/ntv2regroute_8cpp_source.html#l00087">ntv2regroute.cpp:87</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a00aeeb1c32a817cf8a5b71396c8e8dcead307b257181bc49ad4e5e28f16b1a5c7"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a00aeeb1c32a817cf8a5b71396c8e8dcead307b257181bc49ad4e5e28f16b1a5c7">NTV2_CHANNEL3</a></div><div class="ttdeci">@ NTV2_CHANNEL3</div><div class="ttdoc">Specifies channel or Frame Store 3 (or the 3rd item).</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01309">ntv2enums.h:1309</a></div></div>
<div class="ttc" id="antv2enums_8h_html_aced05ac3f96759ff32498fe4fcbba9dfa39fda6163a28fca5d7695e16f1dc9ecb"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#aced05ac3f96759ff32498fe4fcbba9dfa39fda6163a28fca5d7695e16f1dc9ecb">NTV2_REFERENCE_FREERUN</a></div><div class="ttdeci">@ NTV2_REFERENCE_FREERUN</div><div class="ttdoc">Specifies the device's internal clock.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01404">ntv2enums.h:1404</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html">CNTV2Card</a></div><div class="ttdoc">I interrogate and control an AJA video/audio capture/playout device.</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d4b/ntv2card_8h_source.html#l00262">ntv2card.h:262</a></div></div>
<div class="ttc" id="antv2devicefeatures_8hh_html_a22e624db258df962f03a1796e55c5c2b"><div class="ttname"><a href="../../d9/dfb/ntv2devicefeatures_8hh.html#a22e624db258df962f03a1796e55c5c2b">NTV2DeviceGetNumAudioSystems</a></div><div class="ttdeci">UWord NTV2DeviceGetNumAudioSystems(const NTV2DeviceID inDeviceID)</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d0f/ntv2devicefeatures_8hpp_source.html#l09864">ntv2devicefeatures.hpp:9864</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a7446502a7d2e8ea13394b3a4cdaa5b16ab9a97db420ee0bfb6b34b156bb55ea6a"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16ab9a97db420ee0bfb6b34b156bb55ea6a">NTV2_XptSDIIn2</a></div><div class="ttdeci">@ NTV2_XptSDIIn2</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l02472">ntv2enums.h:2472</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a0d9cd9dfba7cb36582da82deef4cb522"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a0d9cd9dfba7cb36582da82deef4cb522">CNTV2Card::GetFrameGeometry</a></div><div class="ttdeci">virtual bool GetFrameGeometry(NTV2FrameGeometry &amp;outValue, NTV2Channel inChannel=NTV2_CHANNEL1)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l00972">ntv2register.cpp:972</a></div></div>
<div class="ttc" id="antv2publicinterface_8h_html_a7d396819a750a83ecd7c2e7f8f4898ec"><div class="ttname"><a href="../../d4/dd7/ntv2publicinterface_8h.html#a7d396819a750a83ecd7c2e7f8f4898ec">DEC</a></div><div class="ttdeci">#define DEC(__x__)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dd7/ntv2publicinterface_8h_source.html#l05579">ntv2publicinterface.h:5579</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a8c757863040a131ff5aa4e0e93284fd4a3b2b3698e844cbe676363f1a5d01363a"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4a3b2b3698e844cbe676363f1a5d01363a">NTV2_XptFrameBuffer2Input</a></div><div class="ttdeci">@ NTV2_XptFrameBuffer2Input</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l02690">ntv2enums.h:2690</a></div></div>
<div class="ttc" id="antv2publicinterface_8h_html_af44baef6120d8ba330b7fa1a8f308fcc"><div class="ttname"><a href="../../d4/dd7/ntv2publicinterface_8h.html#af44baef6120d8ba330b7fa1a8f308fcc">AUTOCIRCULATE_WITH_MULTILINK_AUDIO2</a></div><div class="ttdeci">#define AUTOCIRCULATE_WITH_MULTILINK_AUDIO2</div><div class="ttdoc">Use this to AutoCirculate with base audiosystem controlling base AudioSystem + 2.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dd7/ntv2publicinterface_8h_source.html#l05501">ntv2publicinterface.h:5501</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5a533ead24b07dddb42981aa9944757f46">NTV2_MODE_CAPTURE</a></div><div class="ttdeci">@ NTV2_MODE_CAPTURE</div><div class="ttdoc">Capture (input) mode, which writes into device SDRAM.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01202">ntv2enums.h:1202</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a7446502a7d2e8ea13394b3a4cdaa5b16a408ad54d980889d663444647dea52d0a"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16a408ad54d980889d663444647dea52d0a">NTV2_XptFrameBuffer2YUV</a></div><div class="ttdeci">@ NTV2_XptFrameBuffer2YUV</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l02488">ntv2enums.h:2488</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a7446502a7d2e8ea13394b3a4cdaa5b16aeb92ee9e88c84198ee883600cddaaa02"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a7446502a7d2e8ea13394b3a4cdaa5b16aeb92ee9e88c84198ee883600cddaaa02">NTV2_XptSDIIn1</a></div><div class="ttdeci">@ NTV2_XptSDIIn1</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l02471">ntv2enums.h:2471</a></div></div>
<div class="ttc" id="antv2utils_8h_html_a63e7a951f4cd53108381106ea576d2f3"><div class="ttname"><a href="../../d0/d81/ntv2utils_8h.html#a63e7a951f4cd53108381106ea576d2f3">GetAudioSamplesPerFrame</a></div><div class="ttdeci">ULWord GetAudioSamplesPerFrame(const NTV2FrameRate inFrameRate, const NTV2AudioRate inAudioRate, ULWord inCadenceFrame=0, bool inIsSMPTE372Enabled=false)</div><div class="ttdoc">Returns the number of audio samples for a given video frame rate, audio sample rate,...</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d9b/ntv2utils_8cpp_source.html#l02789">ntv2utils.cpp:2789</a></div></div>
<div class="ttc" id="antv2devicefeatures_8hh_html_ae561712c383551002a87e2b13a4d4296"><div class="ttname"><a href="../../d9/dfb/ntv2devicefeatures_8hh.html#ae561712c383551002a87e2b13a4d4296">NTV2DeviceCanDoStackedAudio</a></div><div class="ttdeci">bool NTV2DeviceCanDoStackedAudio(const NTV2DeviceID inDeviceID)</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d0f/ntv2devicefeatures_8hpp_source.html#l05196">ntv2devicefeatures.hpp:5196</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a8348e43b54cd91f6eb337019abde54af"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a8348e43b54cd91f6eb337019abde54af">NTV2FrameGeometry</a></div><div class="ttdeci">NTV2FrameGeometry</div><div class="ttdoc">Identifies a particular video frame geometry.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l00336">ntv2enums.h:336</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_driver_interface_html_a7e4ebdaf05f325d13582eac32084ee5a"><div class="ttname"><a href="../../d0/dbc/class_c_n_t_v2_driver_interface.html#a7e4ebdaf05f325d13582eac32084ee5a">CNTV2DriverInterface::GetDeviceID</a></div><div class="ttdeci">virtual NTV2DeviceID GetDeviceID(void)</div><div class="ttdef"><b>Definition:</b> <a href="../../de/d85/ntv2driverinterface_8cpp_source.html#l00371">ntv2driverinterface.cpp:371</a></div></div>
<div class="ttc" id="antv2publicinterface_8h_html_ac2cd24508e310b59ed5ab3d0b0bfd999abcaf9fb2675d3698246278f2c22b7a96"><div class="ttname"><a href="../../d4/dd7/ntv2publicinterface_8h.html#ac2cd24508e310b59ed5ab3d0b0bfd999abcaf9fb2675d3698246278f2c22b7a96">kK2RegMaskFrameSize</a></div><div class="ttdeci">@ kK2RegMaskFrameSize</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dd7/ntv2publicinterface_8h_source.html#l01215">ntv2publicinterface.h:1215</a></div></div>
<div class="ttc" id="antv2publicinterface_8h_html_a44465b2926268ea111cf5d357016baefaedeed12a55d2b240e384a99d57e1cc55"><div class="ttname"><a href="../../d4/dd7/ntv2publicinterface_8h.html#a44465b2926268ea111cf5d357016baefaedeed12a55d2b240e384a99d57e1cc55">kRegCh1Control</a></div><div class="ttdeci">@ kRegCh1Control</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dd7/ntv2publicinterface_8h_source.html#l00074">ntv2publicinterface.h:74</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_ad5ffdb2ab1b4f809e318de2655af4c11"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#ad5ffdb2ab1b4f809e318de2655af4c11">CNTV2Card::SetInputFrame</a></div><div class="ttdeci">virtual bool SetInputFrame(const NTV2Channel inChannel, const ULWord inValue)</div><div class="ttdoc">Sets the input frame index number for the given FrameStore. This identifies which frame in device SDR...</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l02225">ntv2register.cpp:2225</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_ae617507f1b0562f866201a58c26e10e7"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#ae617507f1b0562f866201a58c26e10e7">CNTV2Card::AutoCirculateStart</a></div><div class="ttdeci">virtual bool AutoCirculateStart(const NTV2Channel inChannel, const ULWord64 inStartTime=0)</div><div class="ttdoc">Starts AutoCirculating the specified channel that was previously initialized by CNTV2Card::AutoCircul...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/dc3/ntv2autocirculate_8cpp_source.html#l00503">ntv2autocirculate.cpp:503</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_aea2cb5f6e5b491b1db23f7ddcc111033"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#aea2cb5f6e5b491b1db23f7ddcc111033">CNTV2Card::SetMode</a></div><div class="ttdeci">virtual bool SetMode(const NTV2Channel inChannel, const NTV2Mode inNewValue, const bool inIsRetail=true)</div><div class="ttdoc">Determines if a given FrameStore on the AJA device will be used to capture or playout video.</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l01613">ntv2register.cpp:1613</a></div></div>
<div class="ttc" id="aclass_c_n_t_v2_card_html_a086355b86c3de0f733bb98d37f673f77"><div class="ttname"><a href="../../d7/dfb/class_c_n_t_v2_card.html#a086355b86c3de0f733bb98d37f673f77">CNTV2Card::EnableChannel</a></div><div class="ttdeci">virtual bool EnableChannel(const NTV2Channel inChannel)</div><div class="ttdoc">Enables the given FrameStore.</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da9/ntv2register_8cpp_source.html#l02113">ntv2register.cpp:2113</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a0e7716728e9df7086c72609f806dd4a5abec59926c3de1fac4acd02f438a2a634"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a0e7716728e9df7086c72609f806dd4a5abec59926c3de1fac4acd02f438a2a634">NTV2_MODE_DISPLAY</a></div><div class="ttdeci">@ NTV2_MODE_DISPLAY</div><div class="ttdoc">Playout (output) mode, which reads from device SDRAM.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l01200">ntv2enums.h:1200</a></div></div>
<div class="ttc" id="antv2devicefeatures_8h_html_a654a5f0b892e2bce1031b258c723095a"><div class="ttname"><a href="../../d8/d0f/ntv2devicefeatures_8h.html#a654a5f0b892e2bce1031b258c723095a">NTV2DeviceGetNumberFrameBuffers</a></div><div class="ttdeci">ULWord NTV2DeviceGetNumberFrameBuffers(NTV2DeviceID boardID, NTV2FrameGeometry frameGeometry, NTV2FrameBufferFormat frameFormat)</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d86/ntv2devicefeatures_8cpp_source.html#l00510">ntv2devicefeatures.cpp:510</a></div></div>
<div class="ttc" id="antv2enums_8h_html_a8c757863040a131ff5aa4e0e93284fd4a04689c4ed3081db9cd6c99365285fc56"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#a8c757863040a131ff5aa4e0e93284fd4a04689c4ed3081db9cd6c99365285fc56">NTV2_XptSDIOut3Input</a></div><div class="ttdeci">@ NTV2_XptSDIOut3Input</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l02736">ntv2enums.h:2736</a></div></div>
<div class="ttc" id="antv2enums_8h_html_abe5e1274885a1ba60e04e66bb0b41516a3c7784bc2df30c1d0dbd8ca2717d27b8"><div class="ttname"><a href="../../d6/d0c/ntv2enums_8h.html#abe5e1274885a1ba60e04e66bb0b41516a3c7784bc2df30c1d0dbd8ca2717d27b8">NTV2_AUDIOSYSTEM_INVALID</a></div><div class="ttdeci">@ NTV2_AUDIOSYSTEM_INVALID</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d0c/ntv2enums_8h_source.html#l03821">ntv2enums.h:3821</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">The NTV2 SDK</a></li>
    <li class="footer">Generated on Tue Oct 1 2024 16:33:57 for AJA NTV2 SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
